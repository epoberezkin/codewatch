# CodeWatch Phase 2 - Ownership, Components, and File Selection

## Overview

Five interconnected changes to the existing MVP:

1. **GitHub-based ownership** -- Replace the broken `created_by === userId` check with real GitHub API verification (org admin/owner or personal account holder)
2. **Your Projects page** + ownership status on project creation
3. **Responsible disclosure notifications** -- User-initiated owner notification via GitHub issue, time-gating starts from notification, owner always has full access
4. **Component-based architecture** -- Agentic component analysis (tool_use) with security profiling, per-component audits, component selection UI
5. **Smart file selection** -- Grep-augmented Claude planning phase (~5% budget) selects which full files to analyze within a token budget. Costs: 105% full, 38% thorough, 15% opportunistic.

---

## Database Migration (`sql/002_ownership_and_components.sql`)

Single migration file covering all schema changes.

### Ownership

```sql
-- Track whether session token has read:org scope
ALTER TABLE sessions ADD COLUMN has_org_scope BOOLEAN NOT NULL DEFAULT FALSE;

-- Cache ownership lookups (15-min TTL)
CREATE TABLE ownership_cache (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    github_org TEXT NOT NULL,
    is_owner BOOLEAN NOT NULL,
    role TEXT,                           -- 'admin', 'member', or NULL (personal account)
    checked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '15 minutes',
    UNIQUE(user_id, github_org)
);
CREATE INDEX idx_ownership_cache_lookup ON ownership_cache(user_id, github_org, expires_at);
```

### Components

```sql
CREATE TABLE components (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id),
    repo_id UUID NOT NULL REFERENCES repositories(id),
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    role TEXT,                           -- e.g. 'server', 'client', 'shared library'
    file_patterns TEXT[] NOT NULL,       -- glob patterns: ['src/relay/**', 'src/shared/**']
    languages TEXT[] DEFAULT '{}',
    security_profile JSONB,             -- { summary, sensitive_areas: [{path, reason}], threat_surface: [...] }
    estimated_files INTEGER,
    estimated_tokens INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_components_project ON components(project_id);
CREATE INDEX idx_components_repo ON components(repo_id);

-- Track agentic analysis runs
CREATE TABLE component_analyses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id),
    status TEXT NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'running', 'completed', 'failed')),
    turns_used INTEGER DEFAULT 0,
    max_turns INTEGER DEFAULT 40,
    input_tokens_used INTEGER DEFAULT 0,
    output_tokens_used INTEGER DEFAULT 0,
    cost_usd NUMERIC(10,4) DEFAULT 0,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);
CREATE INDEX idx_component_analyses_project ON component_analyses(project_id);

-- Which components were included in each audit
CREATE TABLE audit_components (
    audit_id UUID NOT NULL REFERENCES audits(id),
    component_id UUID NOT NULL REFERENCES components(id),
    tokens_analyzed INTEGER,
    findings_count INTEGER DEFAULT 0,
    PRIMARY KEY (audit_id, component_id)
);

-- Link findings to components
ALTER TABLE audit_findings ADD COLUMN component_id UUID REFERENCES components(id);

-- Track component analysis on projects
ALTER TABLE projects ADD COLUMN component_analysis_id UUID REFERENCES component_analyses(id);
ALTER TABLE projects ADD COLUMN components_analyzed_at TIMESTAMPTZ;

-- Audit: selected components and new status value
ALTER TABLE audits ADD COLUMN selected_component_ids UUID[];
ALTER TABLE audits ADD COLUMN component_analysis_id UUID REFERENCES component_analyses(id);

-- Expand audits.status to include 'component_analysis' and 'planning'
ALTER TABLE audits DROP CONSTRAINT audits_status_check;
ALTER TABLE audits ADD CONSTRAINT audits_status_check
    CHECK (status IN ('pending', 'cloning', 'component_analysis', 'classifying', 'estimating', 'planning', 'analyzing', 'synthesizing', 'completed', 'failed'));

-- Store the audit plan (ranked file list from planning phase)
ALTER TABLE audits ADD COLUMN audit_plan JSONB;  -- [{file, tokens, priority, reason}]

-- Responsible disclosure: track when owner was actually notified
ALTER TABLE audits ADD COLUMN owner_notified_at TIMESTAMPTZ;
```

All changes are additive -- existing data is unaffected. `has_org_scope = FALSE` default is correct for old sessions.

---

## 1. GitHub-Based Ownership

### Problem
Ownership is `projects.created_by === userId` (whoever added the project to CodeWatch). Must be: GitHub org admin/owner or personal account holder.

### Changes

**`src/server/services/github.ts`**:
- Change `getOAuthUrl()` default scope from `''` to `'read:org'`. Add optional `returnTo` state parameter for redirect after re-auth.
- Change `exchangeCodeForToken()` return type to `{ accessToken: string; scope: string }` (GitHub includes `scope` in token response).
- Replace `isOrgMember()` with `getOrgMembershipRole(org, token)`: calls `GET /user/memberships/orgs/{org}` (requires `read:org`), returns `{ role: 'admin'|'member', state: 'active'|'pending' } | null`.
- Add `checkGitHubOwnership(githubOrg, githubUsername, githubToken, hasOrgScope)`:
  - Personal account: `githubOrg.toLowerCase() === githubUsername.toLowerCase()` -> owner. No scope needed.
  - Org account without scope: return `{ isOwner: false, needsReauth: true }`.
  - Org account with scope: call `getOrgMembershipRole()`, owner if `role === 'admin'` and `state === 'active'`.

**New `src/server/services/ownership.ts`**:
- `resolveOwnership(pool, userId, githubOrg, githubUsername, githubToken, hasOrgScope)`:
  - Check `ownership_cache` table first (15-min TTL).
  - Cache miss: call `checkGitHubOwnership()`, cache result (unless `needsReauth`).
  - Return `{ isOwner, role, needsReauth, cached }`.
- `invalidateOwnershipCache(pool, userId)`: called on re-auth.

**`src/server/routes/auth.ts`**:
- `GET /auth/github`: pass `returnTo` query param as base64url state.
- `GET /auth/github/callback`: extract scope from token exchange, store `has_org_scope` in sessions. Decode state for redirect. Invalidate ownership cache on re-auth.
- `requireAuth` middleware: expose `hasOrgScope` on request (from `sessions.has_org_scope`).
- `GET /auth/me`: include `hasOrgScope` in response.

**`src/server/routes/api.ts`** -- Replace all 4 ownership checks:

| Route | Line | Old Check | New Check |
|-------|------|-----------|-----------|
| `POST /api/audit/start` | 512 | `proj[0].created_by === userId` | `resolveOwnership(...).isOwner` |
| `GET /api/audit/:id/report` | 624 | `requesterId === audit.project_owner_id` | `resolveOwnership(...).isOwner` |
| `PATCH /api/findings/:id/status` | 787 | `findings[0].created_by !== userId` | `resolveOwnership(...).isOwner` |
| `POST /api/audit/:id/publish` | 882 | `rows[0].created_by !== userId` | `resolveOwnership(...).isOwner` |

Each query must join `projects` to get `github_org`. Non-owner `needsReauth` returns 403 with `{ needsReauth: true }`.

Add `ownership` field to responses of `POST /api/projects`, `GET /api/projects/:id`.

### Existing Users
- Old sessions get `has_org_scope = FALSE` (migration default) -- correct.
- Personal account ownership works immediately (no scope needed).
- Org ownership: UI shows "Re-authenticate to verify ownership" link -> `/auth/github?returnTo=...`.

---

## 2. Your Projects Page

**New endpoint `GET /api/my/projects`** (requires auth):
- Query `projects WHERE created_by = $1` with audit count, latest severity subqueries.
- For each project: call `resolveOwnership()` (cached, one GitHub API call per unique org).
- Return: `[{ id, name, githubOrg, category, auditCount, latestSeverity, ownership: { isOwner, role, needsReauth }, createdAt }]`.

**New `public/projects.html`**:
- Table: project name, org, audit count, latest severity, ownership badge (Owner/Member/Re-auth needed), "View" link.

**New `src/client/projects.ts`**:
- Fetch `/api/my/projects`, render table, handle re-auth links.

**Nav update** (`src/client/common.ts`):
- Add "My Projects" link visible when logged in.

---

## 3. Responsible Disclosure Notifications

### Problem
Currently `notifyOwnerIfNeeded()` in audit.ts:691-748 **automatically** creates a GitHub issue when a non-owner's audit completes. The time-gating (`publishable_after`) is set at **audit completion** (audit.ts:484-489), not when the owner is actually notified. Three issues:
1. User has no choice — notification is automatic
2. Time-gating starts before the owner learns about the audit
3. Owners should be able to see audits by other users (already works via `isOwner` check, but broken ownership model)

### Solution: User-Initiated Responsible Disclosure

**New flow:**
1. **Audit completes** → `publishable_after` stays **NULL**. Report visible to **requester** (who paid) and **owner** (via `resolveOwnership`) only.
2. **Requester sees "Notify Owner" button** on report page → `POST /api/audit/:id/notify-owner` → creates GitHub issue → sets `owner_notified_at = NOW()` → sets `publishable_after = owner_notified_at + delay`.
3. **No notification = no auto-disclosure.** Report stays between requester and owner indefinitely.
4. **Owner can publish early** at any time via existing publish endpoint.
5. **After `publishable_after`** passes, report auto-publishes (medium+ findings visible to anyone).

**Severity-based delays** (unchanged): critical = 6 months, high/medium = 3 months, low/informational = no delay.

### Changes

**`src/server/services/audit.ts`**:
- Remove `notifyOwnerIfNeeded()` function entirely (lines 691-748).
- Remove `publishable_after` computation from synthesis step (lines 483-489). Set `publishable_after = NULL` on completion.

**New endpoint `POST /api/audit/:id/notify-owner`** (in `api.ts`):
- Requires auth. Requester must be audit's `requester_id`.
- Checks `owner_notified` is not already TRUE (idempotent).
- Creates GitHub issue using `createIssue()` (same format as current).
- Sets `owner_notified = TRUE`, `owner_notified_at = NOW()`.
- Computes and sets `publishable_after = NOW() + delay` based on `max_severity`.
- Returns `{ ok: true, publishableAfter }`.

**`src/server/routes/api.ts`** -- Report access control update:
- **Owner** (via `resolveOwnership`): sees ALL findings always. Already handled by `isOwner` check at line 661.
- **Requester** (non-owner): sees ALL findings of their own audit (they paid for it). New check: `requesterId === audit.requester_id`.
- **Other users**: if `is_public` or `publishable_after` has passed → all findings. Otherwise → only low/informational.

Updated redaction logic:
```
if (isOwner || isRequester) → show everything
else if (audit.is_public) → show everything
else if (publishable_after && now >= publishable_after) → show everything (auto-published)
else if (publishable_after && now < publishable_after) → redact medium+
else (publishable_after is NULL, no notification sent) → redact medium+
```

**Migration addition** (`sql/002_ownership_and_components.sql`):
```sql
ALTER TABLE audits ADD COLUMN owner_notified_at TIMESTAMPTZ;
```
(`owner_notified` BOOLEAN and `publishable_after` TIMESTAMPTZ already exist in schema.)

**Client update** (`src/client/report.ts`):
- If `isRequester && !isOwner && !ownerNotified`: show "Notify Project Owner" button.
- Button calls `POST /api/audit/:id/notify-owner`.
- After notification: show "Owner notified. Report will auto-publish on {date}."

### API response additions
- `GET /api/audit/:id/report`: add `isRequester`, `ownerNotified`, `ownerNotifiedAt` to response.

---

## 4. Smart File Selection (Planning Phase)

### Problem
`selectFiles()` in audit.ts selects by FILE COUNT percentage (e.g., 10% of files for opportunistic). 10% of files != 10% of tokens. The selection uses simple regex path scoring -- Claude should make the prioritization decision based on actual code intelligence.

### Solution: Grep-Augmented Claude Planning Phase

Replace `selectFiles()` with a two-step process: **local grep pre-scoring** (free) + **Claude planning call** (~5% of full audit budget).

**Step 1: Local security greps (zero API cost)**

New `src/server/services/planning.ts`:

Run predefined security-relevant grep patterns across all files in selected components:
- Injection: `eval`, `exec`, `spawn`, `Function(`, `innerHTML`, `dangerouslySetInnerHTML`
- SQL: `query(`, `raw(`, `execute(`, `${}` near SQL keywords
- Auth: `password`, `token`, `session`, `jwt`, `oauth`, `auth`, `login`, `bearer`
- Crypto: `crypto`, `hash`, `encrypt`, `decrypt`, `sign`, `verify`, `hmac`, `aes`, `rsa`
- FS/Network: `readFile`, `writeFile`, `fetch(`, `request(`, `http.`, `net.`, `socket`
- Secrets: `secret`, `key`, `credential`, `api_key`, `private`
- Dangerous: `unsafe`, `TODO`, `FIXME`, `HACK`, `XXX`, `SECURITY`

For each file, produce: `{ filePath, roughTokens, lines, grepHits: number, sampleHits: [{pattern, line, context}] }`.

**Step 2: Claude planning call (~5% budget)**

Send Claude (using the user's API key):
- **Component security profiles** (from agentic analysis): summary, sensitive_areas, threat_surface per selected component -- gives Claude a head start on what matters
- Classification threat model
- File listing with per-file metadata: path, lines of code, token count, grep hit count, top 2-3 sample grep hits with surrounding context
- Token budget for the chosen level (full=100%, thorough=33%, opportunistic=10% of total)
- Instruction: "Create an audit plan. Rank all files by security priority for this threat model and budget. Return JSON."

This is a **single non-agentic call** (no tool_use loop). The heavy exploration was already done during component analysis. This call just synthesizes grep results + security profiles into a prioritized file list.

Claude returns: `[{ file, priority, reason }]` -- an ordered list.

**Step 3: File selection by token budget**

Take files from Claude's priority list in order. Include each file in full (no line-range splitting -- full context needed for security analysis). Accumulate tokens until the level's budget is reached:
- **Full**: 100% of component tokens (all files, planning still useful for batch ordering)
- **Thorough**: 33% of component tokens
- **Opportunistic**: 10% of component tokens

**Cost math (shown to user on estimate page):**
- Planning overhead: ~5% of full token count (the planning prompt is ~10-20K tokens: file listing + grep summaries)
- Full: 5% planning + 100% analysis = **~105% of token cost**
- Thorough: 5% planning + 33% analysis = **~38% of token cost**
- Opportunistic: 5% planning + 10% analysis = **~15% of token cost**

**Update `tokens.ts` `estimateCosts()`:**
- Full: `totalTokens * 1.05` input
- Thorough: `totalTokens * 0.38` input
- Opportunistic: `totalTokens * 0.15` input
- Output estimate: proportional to input (same 5% ratio)

**Update prompts:**
- `prompts/planning.md` (**NEW**): System prompt for the planning phase. Includes instructions to rank files, consider threat model, account for token budget.
- `prompts/thorough.md`: Update to say "You are analyzing the security-critical subset of this codebase, selected by a prior planning step."
- `prompts/opportunistic.md`: Same treatment.
- `prompts/full.md`: Unchanged (analyze everything).

**Updated audit flow (`audit.ts`):**
1. Clone repos
2. Component resolution (filter files by selected components)
3. Classification (unchanged)
4. **NEW: Planning phase** -- set status='planning', run security greps, call Claude for file prioritization, store plan in `audits.audit_plan`
5. File selection from plan (by token budget)
6. Batch and analyze (selected files only)
7. Finding attribution, synthesis

**Files modified/created:**
- `src/server/services/planning.ts` **NEW** -- Local grep scoring + Claude planning call
- `src/server/services/audit.ts` -- Replace `selectFiles()` with planning-based selection, add 'planning' status step
- `src/server/services/tokens.ts` -- Update cost estimation with planning overhead + token-budget percentages
- `prompts/planning.md` **NEW** -- Planning phase prompt
- `prompts/thorough.md`, `prompts/opportunistic.md` -- Update language

---

## 5. Component-Based Architecture

### Agentic Component Analysis + Security Profiling

**New `src/server/services/componentAnalysis.ts`**:

Uses Anthropic SDK `tool_use` loop (from `@anthropic-ai/sdk` already installed) -- "agentic" means: define tools in the API request, Claude calls them, we execute and return results, loop until Claude emits final response. No extra packages needed.

**Three tools:**
1. `list_directory(repo_name, path)` -- `fs.readdirSync`, returns entries with sizes, skips SKIP_DIRS.
2. `read_file(repo_name, path)` -- `readFileContent()`, truncated to 500 lines.
3. `search_files(repo_name, pattern)` -- Glob match against scanned file list.

**Agentic loop:**
1. Build system prompt with repo names, top-level directory listings.
2. Loop (max 40 turns): send messages with tools -> if `stop_reason === 'tool_use'`, execute tools, append results -> if `stop_reason === 'end_turn'`, parse final JSON.
3. Track token usage per turn. Use **Sonnet 4.5** (cheaper: $3/$15 vs $5/$25 per Mtok).
4. Parse output into components, match file patterns against scanned files for token/file counts.
5. Insert into `components` table. Update `projects.component_analysis_id`.

**New `prompts/component_analysis.md`**: Prompt for agentic analysis. Instructions to explore, identify components, AND profile security-sensitive areas per component. Output JSON:
```json
{
  "components": [{
    "name": "string",
    "description": "string",
    "role": "string",
    "repo": "string",
    "file_patterns": ["glob"],
    "languages": ["string"],
    "security_profile": {
      "summary": "Brief security characterization of this component",
      "sensitive_areas": [
        { "path": "src/auth/session.ts", "reason": "Session token generation and validation" },
        { "path": "src/db/queries/*.ts", "reason": "Raw SQL query construction" }
      ],
      "threat_surface": ["authentication", "sql_injection", "session_management"]
    }
  }]
}
```
The agent identifies security areas during its exploration (it's already reading files and understanding structure -- minimal extra cost to also note security-relevant patterns).

**New dependency**: `minimatch` (for glob pattern matching).

### Component Selection Flow

After component analysis, the estimate page shows a table:

| [ ] | Component | Repository | Files | Tokens | Est. Cost |
|-----|-----------|-----------|-------|--------|-----------|

User checks/unchecks components. Cost re-estimates dynamically via `POST /api/estimate/components`.

### New API Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | `/api/projects/:id/analyze-components` | Start agentic analysis. Body: `{ apiKey }`. Returns `{ analysisId }`. |
| GET | `/api/projects/:id/component-analysis/:analysisId` | Poll analysis status + progress. |
| GET | `/api/projects/:id/components` | List project components with file/token counts. |
| POST | `/api/estimate/components` | Body: `{ projectId, componentIds[] }`. Returns scoped cost estimates. |

### Modified Endpoints

- **`POST /api/audit/start`**: Add optional `componentIds: string[]`. Files filtered by component glob patterns. Stored as `audits.selected_component_ids`.
- **`POST /api/estimate`**: Add optional `componentIds`. Scope estimate to selected components.
- **`GET /api/audit/:id/report`**: Include component breakdown: `[{ name, findingsCount, tokensAnalyzed }]`.

### Updated Audit Flow (`audit.ts`)

1. **Clone repos** (unchanged)
2. **Component resolution**: if `selected_component_ids` set, filter files by component patterns. If null and no components exist, use all files (backward compat).
3. **Classification** (unchanged)
4. **Planning phase** (NEW): Run security greps on component files, call Claude to rank files by security priority, select files up to token budget for the chosen level.
5. **Batch and analyze**: Selected files from planning (full files, token-budget-limited for thorough/opportunistic).
6. **Finding attribution**: after inserting findings, match `file_path` to components via glob patterns, set `audit_findings.component_id`.
7. **Synthesis** (enhanced with per-component breakdown)

### Client UI (`estimate.html` + `estimate.ts`)

Add component analysis section to the existing estimate page (between project header and cost cards):
- "Not analyzed" state: API key input + "Analyze Components" button.
- "Analyzing" state: spinner with turn progress (polls every 2s).
- "Complete" state: component table with checkboxes, dynamic cost re-estimation on selection change.

---

## Implementation Phases

### Phase 1: Database Migration + Smart File Selection
- Create `sql/002_ownership_and_components.sql`
- Create `src/server/services/planning.ts` (local grep scoring + Claude planning call)
- Create `prompts/planning.md` (planning phase prompt)
- Replace `selectFiles()` in audit.ts with planning-based selection + token budget
- Update `tokens.ts` cost estimation (planning overhead: 105%/38%/15%)
- Update `thorough.md` and `opportunistic.md` prompts
- Update tests for new estimation values and planning step
- **Verify**: `npm test` passes, estimate values reflect planning overhead

### Phase 2: Ownership Model
- Update `github.ts` (OAuth scope, `getOrgMembershipRole`, `checkGitHubOwnership`)
- Create `ownership.ts` service
- Update `auth.ts` (scope detection, `has_org_scope` storage, state parameter)
- Update `api.ts` (replace all 4 ownership checks, add ownership to project responses)
- Update test mocks and test helpers (`has_org_scope` parameter)
- Add ownership tests
- **Verify**: `npm test` passes, existing auth tests still pass

### Phase 3: Responsible Disclosure + Your Projects Page
- Remove `notifyOwnerIfNeeded()` from audit.ts, remove `publishable_after` from synthesis
- Add `POST /api/audit/:id/notify-owner` endpoint (creates issue, sets `owner_notified_at`, computes `publishable_after`)
- Update report access control: requester sees own audit findings, owner sees all via `resolveOwnership`
- Update report response: add `isRequester`, `ownerNotified`, `ownerNotifiedAt`
- Update `report.ts` client: "Notify Owner" button for non-owner requesters
- Add `GET /api/my/projects` endpoint
- Create `public/projects.html` and `src/client/projects.ts`
- Update nav in `common.ts`
- Add notification and my/projects tests
- **Verify**: `npm test` passes, manual test -- non-owner sees notify button, time-gating starts from notification

### Phase 4: Component Analysis Service
- Install `minimatch`
- Create `componentAnalysis.ts` with tool definitions, agentic loop, component parsing
- Create `prompts/component_analysis.md`
- Add component analysis API endpoints (start, poll, list)
- Add component analysis tests (mock Claude tool_use responses)
- **Verify**: `npm test` passes, mock component analysis completes

### Phase 5: Component Selection + Audit Integration
- Add `POST /api/estimate/components` endpoint
- Modify `POST /api/audit/start` to accept `componentIds`
- Update `runAudit()` for component-based file filtering
- Add finding-to-component attribution
- Add per-component breakdown to report
- Update estimate page UI with component table
- Update audit tests
- **Verify**: Full flow -- analyze components -> select -> estimate -> audit -> report with component breakdown

---

## Files Modified (Summary)

| File | Changes |
|------|---------|
| `sql/002_ownership_and_components.sql` | **NEW** -- Migration |
| `src/server/services/github.ts` | OAuth scope, `getOrgMembershipRole()`, `checkGitHubOwnership()`, remove `isOrgMember()` |
| `src/server/services/ownership.ts` | **NEW** -- Cached ownership resolution |
| `src/server/services/componentAnalysis.ts` | **NEW** -- Agentic component analysis (tool_use) |
| `src/server/services/planning.ts` | **NEW** -- Local grep scoring + Claude planning call |
| `src/server/services/audit.ts` | Remove `notifyOwnerIfNeeded()`, remove `publishable_after` from synthesis, replace `selectFiles()` with planning-based selection, add component file filtering, finding attribution |
| `src/server/services/tokens.ts` | Fix estimation: planning overhead (105%/38%/15%), add `estimateCostsForComponents()` |
| `src/server/routes/auth.ts` | Scope detection, `has_org_scope`, state parameter, updated requireAuth |
| `src/server/routes/api.ts` | Replace 4 ownership checks, add 6 new endpoints (incl. notify-owner), update report access control (requester sees own), add ownership to responses |
| `prompts/component_analysis.md` | **NEW** -- Agentic analysis prompt |
| `prompts/planning.md` | **NEW** -- Planning phase prompt |
| `prompts/thorough.md` | Update: analyzing security-critical subset selected by planning phase |
| `prompts/opportunistic.md` | Update: analyzing high-priority subset selected by planning phase |
| `public/projects.html` | **NEW** -- Your Projects page |
| `src/client/projects.ts` | **NEW** -- Projects page client |
| `src/client/common.ts` | Add `hasOrgScope` to auth, "My Projects" nav link |
| `src/client/estimate.ts` | Add component analysis UI, selection table, dynamic re-estimation |
| `src/client/report.ts` | Handle `needsReauth`, "Notify Owner" button, component breakdown |
| `test/helpers.ts` | Add `hasOrgScope` parameter |
| `test/mocks/github.ts` | Add ownership mocks |
| `test/api/ownership.test.ts` | **NEW** -- Ownership tests |
| `test/api/components.test.ts` | **NEW** -- Component analysis tests |

---

## Verification

1. `npm test` -- all existing + new tests pass
2. `npm run test:coverage` -- verify new services have reasonable coverage
3. Manual: create project -> verify ownership badge (personal account: immediate, org: needs re-auth)
4. Manual: "My Projects" page shows all added projects with correct ownership
5. Manual: non-owner runs audit -> report shows "Notify Owner" button -> click creates GitHub issue -> `publishable_after` set from NOW, not from audit completion
6. Manual: owner sees all audits on project (including non-owner audits) with full findings
7. Manual: no notification -> `publishable_after` stays NULL -> medium+ findings redacted for third parties indefinitely
8. Manual: estimate page shows component analysis section, run analysis, component table appears
9. Manual: select/deselect components, costs update dynamically (105%/38%/15% multipliers)
10. Manual: start audit -> verify planning phase runs (status='planning', grep hits logged, Claude planning call made)
11. Manual: thorough audit -> verify only ~38% of tokens sent (planning 5% + analysis 33%), not all files
12. Manual: start audit with selected components -> report shows component breakdown
13. Manual: verify audit_plan stored in DB with ranked file list and reasons

# CodeWatch Phase 2 - Ownership, Components, and File Selection

## Overview

Nine interconnected changes to the existing MVP:

1. **Development gate** -- Password-protected access for pre-launch testing
2. **Bug fixes + infrastructure** -- Snake_case→camelCase mismatch, broken reports page, irreversible publish, missing deletion, unconstrained filters, shallow clones + clone progress
3. **GitHub-based ownership** -- Replace broken `created_by === userId` with real GitHub API verification
4. **Project pages** -- `/projects` public browse (projects with public reports only), `/project/:id` detail page, "My Projects" filter
5. **Responsible disclosure** -- User-initiated owner notification via GitHub issue, time-gating starts from notification
6. **Component-based architecture** -- Agentic analysis (SDK tool_use) with security profiling + dependency identification, three-phase estimation
7. **Smart file selection** -- Grep-augmented Claude planning phase (~5% budget), token-budget file selection. Costs: 105%/38%/15%
8. **Report enhancements** -- Include threat model, classification, component structure, dependencies in report
9. **Supply chain navigation** -- Dependencies listed per repo, "Add as Project" to audit the whole dependency chain

---

## Database Migration (`sql/002_ownership_and_components.sql`)

Single migration file covering all schema changes.

### Ownership

```sql
-- Track whether session token has read:org scope
ALTER TABLE sessions ADD COLUMN has_org_scope BOOLEAN NOT NULL DEFAULT FALSE;

-- Cache ownership lookups (15-min TTL)
CREATE TABLE ownership_cache (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    github_org TEXT NOT NULL,
    is_owner BOOLEAN NOT NULL,
    role TEXT,                           -- 'admin', 'member', or NULL (personal account)
    checked_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL DEFAULT NOW() + INTERVAL '15 minutes',
    UNIQUE(user_id, github_org)
);
CREATE INDEX idx_ownership_cache_lookup ON ownership_cache(user_id, github_org, expires_at);
```

### Components

```sql
CREATE TABLE components (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id),
    repo_id UUID NOT NULL REFERENCES repositories(id),
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    role TEXT,                           -- e.g. 'server', 'client', 'shared library'
    file_patterns TEXT[] NOT NULL,       -- glob patterns: ['src/relay/**', 'src/shared/**']
    languages TEXT[] DEFAULT '{}',
    security_profile JSONB,             -- { summary, sensitive_areas: [{path, reason}], threat_surface: [...] }
    estimated_files INTEGER,
    estimated_tokens INTEGER,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX idx_components_project ON components(project_id);
CREATE INDEX idx_components_repo ON components(repo_id);

-- Track agentic analysis runs
CREATE TABLE component_analyses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id),
    status TEXT NOT NULL DEFAULT 'pending'
        CHECK (status IN ('pending', 'running', 'completed', 'failed')),
    turns_used INTEGER DEFAULT 0,
    max_turns INTEGER DEFAULT 40,
    input_tokens_used INTEGER DEFAULT 0,
    output_tokens_used INTEGER DEFAULT 0,
    cost_usd NUMERIC(10,4) DEFAULT 0,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);
CREATE INDEX idx_component_analyses_project ON component_analyses(project_id);

-- Which components were included in each audit
CREATE TABLE audit_components (
    audit_id UUID NOT NULL REFERENCES audits(id),
    component_id UUID NOT NULL REFERENCES components(id),
    tokens_analyzed INTEGER,
    findings_count INTEGER DEFAULT 0,
    PRIMARY KEY (audit_id, component_id)
);

-- Link findings to components
ALTER TABLE audit_findings ADD COLUMN component_id UUID REFERENCES components(id);

-- Track component analysis on projects
ALTER TABLE projects ADD COLUMN component_analysis_id UUID REFERENCES component_analyses(id);
ALTER TABLE projects ADD COLUMN components_analyzed_at TIMESTAMPTZ;

-- Audit: selected components and new status value
ALTER TABLE audits ADD COLUMN selected_component_ids UUID[];
ALTER TABLE audits ADD COLUMN component_analysis_id UUID REFERENCES component_analyses(id);

-- Expand audits.status to include 'planning' (component_analysis is tracked separately in component_analyses table)
ALTER TABLE audits DROP CONSTRAINT audits_status_check;
ALTER TABLE audits ADD CONSTRAINT audits_status_check
    CHECK (status IN ('pending', 'cloning', 'classifying', 'estimating', 'planning', 'analyzing', 'synthesizing', 'completed', 'failed'));

-- Store the audit plan (ranked file list from planning phase)
ALTER TABLE audits ADD COLUMN audit_plan JSONB;  -- [{file, tokens, priority, reason}]

-- Responsible disclosure: track when owner was actually notified
ALTER TABLE audits ADD COLUMN owner_notified_at TIMESTAMPTZ;
```

### Dependencies

```sql
CREATE TABLE project_dependencies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id),
    repo_id UUID REFERENCES repositories(id),       -- which repo declared this dependency
    name TEXT NOT NULL,                              -- e.g. 'express', 'tokio', 'aeson'
    version TEXT,                                    -- e.g. '^5.2.1', '>=1.0'
    ecosystem TEXT NOT NULL,                         -- 'npm', 'cargo', 'pip', 'go', 'maven', etc.
    source_repo_url TEXT,                            -- GitHub URL if identifiable
    linked_project_id UUID REFERENCES projects(id),  -- if added as a CodeWatch project
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(project_id, repo_id, name, ecosystem)
);
CREATE INDEX idx_project_deps_project ON project_dependencies(project_id);
CREATE INDEX idx_project_deps_linked ON project_dependencies(linked_project_id);
```

All changes are additive -- existing data is unaffected. `has_org_scope = FALSE` default is correct for old sessions.

---

## 1. Development Gate Page

Simple password-protected middleware for pre-launch testing.

**`src/server/middleware/gate.ts`** (NEW):
- Reads `GATE_PASSWORD` from env. If not set, gate is disabled (open access).
- Middleware checks **signed** `gate` cookie (uses `COOKIE_SECRET` already configured for cookie-parser). Cookie value is a HMAC of the password — cannot be guessed or forged.
- `POST /gate` endpoint: validates password, sets signed `gate` cookie (httpOnly, 30 days), redirects to `/`.

**`public/gate.html`** (NEW):
- Minimal page: password input + submit button. Error message on wrong password.

**`src/server/index.ts`**:
- Mount gate middleware BEFORE all other routes (after cookie-parser).
- Exclude `/gate`, `/gate.html`, and all static assets (`/public/*` — CSS, JS, images) from the gate check. Only API routes and HTML pages are gated.

**`.env` additions**:
```
GATE_PASSWORD=your-password-here
COOKIE_SECRET=<random 32+ char string>  # generate: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

Note: `COOKIE_SECRET` is already used by cookie-parser for session signing. If not already set, this adds it.

---

## 2. Bug Fixes

### 2a. Empty Report Sections (snake_case mismatch)

Synthesis prompt (audit.ts:463-466) returns `executive_summary`, `security_posture` (snake_case). API (api.ts:685) passes raw JSONB as-is. Client (report.ts:34-37) reads `executiveSummary`, `securityPosture` (camelCase). Result: `undefined`.

**Fix**: Update client to use snake_case keys matching the JSONB data from Claude. No API transformation needed — the data passes through as-is:
```typescript
// report.ts — change interface and rendering to use snake_case keys:
reportSummary: {
  executive_summary: string;
  security_posture: string;
  responsible_disclosure: Record<string, string>;
} | null;
```

Also move inline synthesis prompt to `prompts/synthesize.md`.

### 2b. Public Reports Page Broken

`public/reports.html` exists but has no client-side script. No `reports.ts` exists. The `/api/reports` endpoint works but nothing calls it.

**Fix**: This page is superseded by the new `/projects` browse page (Section 4). Remove `reports.html`. The projects page shows projects with public reports and user's reports (showing if it is public or private) and links to audit reports.

### 2c. Publish Is Irreversible

Currently `POST /api/audit/:id/publish` sets `is_public = TRUE` with no way to undo.

**Fix**: Add `POST /api/audit/:id/unpublish`:
- Owner (via `resolveOwnership`) can set `is_public = FALSE`.
- Reset `publishable_after` to NULL (stops auto-publish timer).

### 2d. Missing Audit Deletion

Audit requester should be able to delete their own audit.

**Fix**: Add `DELETE /api/audit/:id`:
- Requires auth. Only audit's `requester_id` can delete.
- Cascades: delete `audit_findings`, `audit_commits`, `audit_components`, then `audits` row.
- Returns 204 No Content.

### 2e. Missing Project Removal

Project creator should be able to remove their project.

**Fix**: Add `DELETE /api/projects/:id`:
- Requires auth. Only `created_by` user (or owner via `resolveOwnership`) can delete.
- **Guard**: Reject if project has audits created by OTHER users (can't delete other people's work). Only allow deletion if all audits are by the requester, or project has zero audits.
- Cascades: delete `project_repos` rows (keep repository records — they may be shared with other projects), `components`, `project_dependencies`, `audits` (own only), then `projects` row.

### 2f. Report Filters Not Constrained

Severity and status dropdowns on report page show all options regardless of what findings exist.

**Fix**: In `report.ts`, after loading findings, populate filter dropdowns with only the severity/status values that actually appear in the findings. Add "all" as default option, then only severities/statuses with at least one finding.

### 2g. Shallow Clones + Clone Progress

**Problem**: Current `cloneOrUpdate()` uses `--single-branch` but downloads full history. A 5-repo project took 4.5GB — would be far less with shallow clones.

**Fix — Shallow clones** (`src/server/services/git.ts`):
- **Initial clone**: `git clone --depth 1 --single-branch <url>` — only latest commit's tree, minimal download.
- **Incremental audit (repo on disk)**: `git fetch --shallow-since=<date>` — deepens just enough to include the base commit SHA, then `diffBetweenCommits()` works normally.
- **Incremental audit (repo missing)**: `git clone --shallow-since=<date> --single-branch <url>` — same history window.

The `--shallow-since` date comes from the **base commit's actual git timestamp** (not our audit timestamp):
1. Look up base audit's SHA from `audit_commits` table.
2. Call GitHub API: `GET /repos/{owner}/{repo}/commits/{sha}` → `commit.committer.date`.
3. Subtract 1 day (buffer for timezone/force-push edge cases) → use as `--shallow-since` value.

Updated signature:
```typescript
cloneOrUpdate(repoUrl: string, branch?: string, shallowSince?: Date): Promise<{ localPath: string; headSha: string }>
```

**Fix — Clone progress** (`src/server/services/audit.ts` + `api.ts`):
- Store clone progress in existing `audits.progress_detail` JSONB column (e.g., `{ "clone_progress": "Cloning 2/5: simplexmq" }`). No schema change needed.
- Update progress per-repo during the clone step.
- Client polls existing status endpoint and displays which repo is being downloaded.

**`src/server/services/github.ts`** addition:
- `getCommitDate(owner, repo, sha, token?)`: calls `GET /repos/{owner}/{repo}/commits/{sha}` (public repos need no auth), returns `Date`.

---

## 3. GitHub-Based Ownership

### Problem
Ownership is `projects.created_by === userId` (whoever added the project to CodeWatch). Must be: GitHub org admin/owner or personal account holder.

### Changes

**`src/server/services/github.ts`**:
- Change `getOAuthUrl()` default scope from `''` to `'read:org'`. Add optional `returnTo` state parameter for redirect after re-auth.
- Change `exchangeCodeForToken()` return type to `{ accessToken: string; scope: string }` (GitHub includes `scope` in token response).
- Replace `isOrgMember()` with `getOrgMembershipRole(org, token)`: calls `GET /user/memberships/orgs/{org}` (requires `read:org`), returns `{ role: 'admin'|'member', state: 'active'|'pending' } | null`.
- Add `checkGitHubOwnership(githubOrg, githubUsername, githubToken, hasOrgScope)`:
  - Personal account: `githubOrg.toLowerCase() === githubUsername.toLowerCase()` -> owner. No scope needed.
  - Org account without scope: return `{ isOwner: false, needsReauth: true }`.
  - Org account with scope: call `getOrgMembershipRole()`, owner if `role === 'admin'` and `state === 'active'`.

**New `src/server/services/ownership.ts`**:
- `resolveOwnership(pool, userId, githubOrg, githubUsername, githubToken, hasOrgScope)`:
  - Check `ownership_cache` table first (15-min TTL).
  - Cache miss: call `checkGitHubOwnership()`, cache result (unless `needsReauth`).
  - Return `{ isOwner, role, needsReauth, cached }`.
- `invalidateOwnershipCache(pool, userId)`: called on re-auth.

**`src/server/routes/auth.ts`**:
- `GET /auth/github`: pass `returnTo` query param as HMAC-signed base64url state (signed with `COOKIE_SECRET` to prevent open redirect attacks).
- `GET /auth/github/callback`: extract scope from token exchange, store `has_org_scope` in sessions. Decode state for redirect. Invalidate ownership cache on re-auth.
- `requireAuth` middleware: expose `hasOrgScope` on request (from `sessions.has_org_scope`).
- `GET /auth/me`: include `hasOrgScope` in response.

**`src/server/routes/api.ts`** -- Replace all 4 ownership checks:

| Route | Line | Old Check | New Check |
|-------|------|-----------|-----------|
| `POST /api/audit/start` | 512 | `proj[0].created_by === userId` | `resolveOwnership(...).isOwner` (records only — does NOT reject non-owners; any authenticated user can start audits) |
| `GET /api/audit/:id/report` | 624 | `requesterId === audit.project_owner_id` | `resolveOwnership(...).isOwner` |
| `PATCH /api/findings/:id/status` | 787 | `findings[0].created_by !== userId` | `resolveOwnership(...).isOwner` |
| `POST /api/audit/:id/publish` | 882 | `rows[0].created_by !== userId` | `resolveOwnership(...).isOwner` |

Each query must join `projects` to get `github_org`. Non-owner `needsReauth` returns 403 with `{ needsReauth: true }`.

Add `ownership` field to responses of `POST /api/projects`, `GET /api/projects/:id`.

### Existing Users
- Old sessions get `has_org_scope = FALSE` (migration default) -- correct.
- Personal account ownership works immediately (no scope needed).
- Org ownership: UI shows "Re-authenticate to verify ownership" link -> `/auth/github?returnTo=...`.

---

## 4. Project Pages

### Public Browse: `/projects`

**`GET /api/projects/browse`** (no auth required):
- Projects with at least one public (`is_public = TRUE`) audit.
- Return: `[{ id, name, githubOrg, category, license, publicAuditCount, latestPublicSeverity, latestAuditDate }]`.
- Filters: `?category=`, `?severity=`, `?search=` (name/org substring), `?mine=true` (requires auth).

**`public/projects.html`** + **`src/client/projects.ts`**:
- Project cards/table with category badges, license, severity indicators, search bar.
- **"My Projects" filter** (checkbox, visible when logged in): when checked, calls same endpoint with `?mine=true` to show only user's projects (regardless of public status), with ownership badges.
- Click project → `/project.html?id=...`.

**`GET /api/projects/browse?mine=true`** (requires auth):
- All projects where `created_by = userId`, with audit count, latest severity.
- For each: `resolveOwnership()` (cached). Return ownership badge.
- Return adds: `ownership: { isOwner, role, needsReauth }`.

### Project Detail: `/project/:id`

**`GET /api/projects/:id/detail`** (public, but content varies by auth):
- Project metadata: name, org, category, description, **license** (from repositories table).
- Threat model: parties with can/cannot, source (repo or generated), evaluation.
- Involved parties: vendor, operators, end_users, networks.
- **Components**: list with roles, languages, security profiles (if analyzed).
- **Dependencies**: list from `project_dependencies` with ecosystem, version, linked project badge.
- **Audits**: last 10 audits visible to the viewer, latest first:
  - Public audits: visible to all.
  - Non-public: visible to owner and requester only.
  - Each: id, level, status, maxSeverity, createdAt, completedAt, isPublic.

**`public/project.html`** + **`src/client/project.ts`** (NEW):
- Project header with metadata + license badge.
- Threat model section (parties with can/cannot).
- Components table (if analyzed).
- Dependencies list with "Add as Project" buttons for unlinked deps.
- Audit history table (last 10) with links to reports.
- Delete project button (only if creator and no foreign audits).

**Nav update** (`src/client/common.ts`):
- "Projects" link always visible in nav.

### Ownership Note
Finding status changes (`PATCH /api/findings/:id/status`) already require owner check (api.ts:787). Currently uses broken `created_by` check — fixed by ownership model (Section 3).

---

## 5. Responsible Disclosure Notifications

### Problem
Currently `notifyOwnerIfNeeded()` in audit.ts:691-748 **automatically** creates a GitHub issue when a non-owner's audit completes. The time-gating (`publishable_after`) is set at **audit completion** (audit.ts:484-489), not when the owner is actually notified. Three issues:
1. User has no choice — notification is automatic
2. Time-gating starts before the owner learns about the audit
3. Owners should be able to see audits by other users (already works via `isOwner` check, but broken ownership model)

### Solution: User-Initiated Responsible Disclosure

**New flow:**
1. **Audit completes** → `publishable_after` stays **NULL**. Report visible to **owner** (via `resolveOwnership`) with full findings. **Non-owners** (including the requester who paid) see a redacted version: medium+ findings show severity, category, and component only — no description, file path, or code snippets. A notice explains the requester is supporting the project's security.
2. **Requester sees "Notify Owner" button** on report page → `POST /api/audit/:id/notify-owner` → creates GitHub issue → sets `owner_notified_at = NOW()` → sets `publishable_after = owner_notified_at + delay`.
3. **No notification = no auto-disclosure.** Report stays between requester and owner indefinitely.
4. **Owner can publish early** at any time via existing publish endpoint.
5. **After `publishable_after`** passes, report auto-publishes (medium+ findings visible to anyone).

**Severity-based delays** (unchanged): critical = 6 months, high/medium = 3 months, low/informational = no delay.

### Changes

**`src/server/services/audit.ts`**:
- Remove `notifyOwnerIfNeeded()` function entirely (lines 691-748).
- Remove `publishable_after` computation from synthesis step (lines 483-489). Set `publishable_after = NULL` on completion.

**New endpoint `POST /api/audit/:id/notify-owner`** (in `api.ts`):
- Requires auth. Requester must be audit's `requester_id`.
- Checks `owner_notified` is not already TRUE (idempotent).
- Creates GitHub issue using `createIssue()` (same format as current).
- Sets `owner_notified = TRUE`, `owner_notified_at = NOW()`.
- Computes and sets `publishable_after = NOW() + delay` based on `max_severity`.
- Returns `{ ok: true, publishableAfter }`.

**`src/server/routes/api.ts`** -- Report access control update:
- **Owner** (via `resolveOwnership`): sees ALL findings always.
- **Everyone else** (including the requester who paid): sees redacted findings for medium+ severity until published. Non-owner requesters are supporting the project by paying for its security audit — they see a list of redacted issues with a notice explaining this.

Updated three-tier access model (reports are ALWAYS accessible via direct URL — no 404):
```
-- All reports accessible to anyone. Content varies by viewer:

Tier 1 — Owner (via resolveOwnership):
  → Full report: all findings with complete details.

Tier 2 — Requester (audits.requester_id === userId):
  → Redacted findings list: each finding shows severity, category, affected component.
    Details hidden: description, file_path, code_snippet, exploitation, recommendation.
  → Notice: "Some findings are redacted. By requesting this audit you are
    supporting the security of this project. Full findings will be
    available after the responsible disclosure period."

Tier 3 — Everyone else (anonymous, other authenticated users):
  → Summary only: finding count, max severity, audit date, audit level.
    No individual findings shown.
  → Notice: "Only project owners can see the full report."

-- Exceptions (override to full access for everyone):
if (audit.is_public) → Tier 1 for all viewers
if (publishable_after && now >= publishable_after) → Tier 1 for all viewers (lazy auto-publish)
```

**Auto-publish is lazy**: no background job. Each report access checks `publishable_after` against current time. `is_public` remains FALSE until the owner explicitly publishes via the publish endpoint. The browse page (`GET /api/projects/browse`) only shows projects where `is_public = TRUE` — auto-published reports (via lazy `publishable_after` check) are accessible via direct URL but do not appear in the browse listing until the owner explicitly publishes.

**Migration addition** (`sql/002_ownership_and_components.sql`):
```sql
ALTER TABLE audits ADD COLUMN owner_notified_at TIMESTAMPTZ;
```
(`owner_notified` BOOLEAN and `publishable_after` TIMESTAMPTZ already exist in schema.)

**Client update** (`src/client/report.ts`):
- If `isOwner === false && isRequester === true && !ownerNotified`: show "Notify Project Owner" button.
- Button calls `POST /api/audit/:id/notify-owner`.
- After notification: show "Owner notified. Report will auto-publish on {date}."
- If `redactionNotice` present: show notice banner above findings explaining redaction and the requester's contribution to project security.

### API response additions
- `GET /api/audit/:id/report`: add `isOwner`, `isRequester` (boolean — for UI only, NOT for redaction), `ownerNotified`, `ownerNotifiedAt`, `redactionNotice` (string, present when findings are redacted) to response.

---

## 6. Component-Based Architecture

### Agentic Component Analysis + Security Profiling

**New `src/server/services/componentAnalysis.ts`**:

Uses Anthropic SDK `tool_use` loop (from `@anthropic-ai/sdk` already installed) -- "agentic" means: define tools in the API request, Claude calls them, we execute and return results, loop until Claude emits final response. No extra packages needed.

**Three tools:**
1. `list_directory(repo_name, path)` -- `fs.readdirSync`, returns entries with sizes, skips SKIP_DIRS.
2. `read_file(repo_name, path)` -- `readFileContent()`, truncated to 500 lines.
3. `search_files(repo_name, pattern)` -- Glob match against scanned file list.

**Agentic loop:**
1. Build system prompt with repo names, top-level directory listings.
2. Loop (max 40 turns): send messages with tools -> if `stop_reason === 'tool_use'`, execute tools, append results -> if `stop_reason === 'end_turn'`, parse final JSON.
3. Track token usage per turn. Use **Sonnet 4.5** (cheaper: $3/$15 vs $5/$25 per Mtok).
4. Parse output into components, match file patterns against scanned files for token/file counts.
5. Insert into `components` table. Update `projects.component_analysis_id`.

**New `prompts/component_analysis.md`**: Prompt for agentic analysis. Instructions to explore, identify components, AND profile security-sensitive areas per component. Output JSON:
```json
{
  "components": [{
    "name": "string",
    "description": "string",
    "role": "string",
    "repo": "string",
    "file_patterns": ["glob"],
    "languages": ["string"],
    "security_profile": {
      "summary": "Brief security characterization of this component",
      "sensitive_areas": [
        { "path": "src/auth/session.ts", "reason": "Session token generation and validation" },
        { "path": "src/db/queries/*.ts", "reason": "Raw SQL query construction" }
      ],
      "threat_surface": ["authentication", "sql_injection", "session_management"]
    }
  }]
}
```
The agent identifies security areas AND dependencies during its exploration (it's already reading files and navigating repos -- minimal extra cost to also read manifest files and note security-relevant patterns).

Extended output includes `dependencies` array (see Section 9 for format).

**Re-analysis**: Users can re-run component analysis at any time (e.g., after repo structure changes). Re-analysis replaces old components with new ones. Previous audits retain their `component_analysis_id` and `audit_components` references — they are not affected by re-analysis. The new analysis gets a new `component_analyses` row; the project's `component_analysis_id` is updated to point to the latest.

**New dependency**: `minimatch` (for glob pattern matching).

### Three-Phase Estimation Flow

Component analysis costs money (Sonnet 4.5, user's API key). The estimate page has three stages:

**Stage 1 — Free scan** (no API key needed):
- Repos already cloned during project creation. File scan gives total files + tokens.
- Show: total file count, total tokens, rough cost estimates per level (105%/38%/15%).
- Show: "To refine estimates, run component analysis" prompt.

**Stage 2 — Component analysis** (costs money):
- User enters API key → "Analyze Components" button → agentic Sonnet loop runs.
- Progress shown: turn count, cost so far (polls every 2s).
- On completion: component table appears with checkboxes:

| [x] | Component | Repository | Role | Files | Tokens | Security Profile |
|-----|-----------|-----------|------|-------|--------|------------------|

- User checks/unchecks components → cost re-estimates dynamically via `POST /api/estimate/components`.
- Scoped estimates shown per level: 105%/38%/15% of selected component tokens.

**Stage 3 — Audit** (user clicks "Start Audit"):
- Level selection (full/thorough/opportunistic).
- Planning phase runs (5% budget) → file selection → analysis → synthesis.

### New API Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | `/api/projects/:id/analyze-components` | Start agentic analysis. Body: `{ apiKey }`. Returns `{ analysisId }`. |
| GET | `/api/projects/:id/component-analysis/:analysisId` | Poll analysis status + progress. |
| GET | `/api/projects/:id/components` | List project components with file/token counts. |
| POST | `/api/estimate/components` | Body: `{ projectId, componentIds[] }`. Returns scoped cost estimates. |

### Modified Endpoints

- **`POST /api/audit/start`**: Add optional `componentIds: string[]`. Files filtered by component glob patterns. Stored as `audits.selected_component_ids`.
- **`POST /api/estimate`**: Add optional `componentIds`. Scope estimate to selected components.
- **`GET /api/audit/:id/report`**: Include component breakdown: `[{ name, findingsCount, tokensAnalyzed }]`.

### Updated Audit Flow (`audit.ts`)

1. **Clone repos** (unchanged)
2. **Component resolution**: if `selected_component_ids` set, filter files by component patterns. If null and no components exist, use all files (backward compat).
3. **Classification** (unchanged)
4. **Planning phase** (NEW): Run security greps on component files, call Claude to rank files by security priority, select files up to token budget for the chosen level.
5. **Batch and analyze**: Selected files from planning (full files, token-budget-limited for thorough/opportunistic).
6. **Finding attribution**: after inserting findings, match `file_path` to components via glob patterns, set `audit_findings.component_id`.
7. **Synthesis** (enhanced with per-component breakdown)

### Client UI (`estimate.html` + `estimate.ts`)

Estimate page progresses through three visible stages:
- **Stage 1** (always visible): Total file count + tokens at top. Rough cost cards per level (105%/38%/15%). Prompt: "Run component analysis for refined estimates and security profiling."
- **Stage 2 — Not analyzed**: API key input + "Analyze Components" button.
- **Stage 2 — Analyzing**: Spinner with turn count + cost so far (polls every 2s). Per-repo clone progress shown during clone step.
- **Stage 2 — Complete**: Component table with checkboxes, security profile summaries, dynamic cost re-estimation on selection change. Scoped cost cards replace rough estimates.
- **Stage 3**: Level selection dropdown + "Start Audit" button (enabled after component selection).

---

## 7. Smart File Selection

### Problem

Current `selectFiles()` in audit.ts takes all scanned files and batches them for analysis. For "thorough" and "opportunistic" levels, files are selected by token count alone — no intelligence about which files matter most for security. The planning phase adds a security-informed file selection step.

### Grep-Augmented Claude Planning Phase

A single non-agentic Claude call (~5% of the audit's token budget) that uses three inputs to produce a ranked file list:

**Step 1 — Local security greps** (no API call, runs on server):
- Run regex patterns against component files looking for security-relevant code:
  - Injection: `eval\(`, `exec\(`, `spawn\(`, `Function\(`
  - SQL: `query\(`, `\.raw\(`, `\.execute\(`
  - Auth: `password`, `token`, `secret`, `credential`, `auth`, `session`
  - Crypto: `crypto`, `hash`, `encrypt`, `decrypt`, `sign`, `verify`
  - Network: `fetch\(`, `http`, `socket`, `listen`, `cors`
  - File I/O: `readFile`, `writeFile`, `unlink`, `chmod`
- For each file: count total grep hits, collect top 3 sample hits (pattern, line number, surrounding line text).
- Output: `Array<{ file: string, tokens: number, grepHits: number, samples: Array<{ pattern, lineNo, text }> }>`.

**Step 2 — Claude planning call** (single API request, **Sonnet 4.5**):
- System prompt from `prompts/planning.md`.
- User message includes:
  - **Component security profiles** (from Section 6): `sensitive_areas` and `threat_surface` per component.
  - **Grep results**: file list with hit counts and samples.
  - **Classification threat model**: parties with can/cannot, project category.
  - **Audit level**: full/thorough/opportunistic.
- Claude returns: ranked file list `[{ file, priority: 1-10, reason: string }]` ordered by security importance.

**Step 3 — Token-budget file selection**:
- Walk the ranked list top-down, accumulating token counts.
- **Full**: 100% of tokens (all files, planning just determines analysis order).
- **Thorough**: ~33% of total tokens.
- **Opportunistic**: ~10% of total tokens.
- Store selected list as `audits.audit_plan` JSONB: `[{ file, tokens, priority, reason }]`.

### Cost Estimation Updates

Planning overhead changes the cost multipliers in `tokens.ts`:
- **Full**: 100% analysis + 5% planning = **105%** of token cost.
- **Thorough**: 33% analysis + 5% planning = **38%** of token cost.
- **Opportunistic**: 10% analysis + 5% planning = **15%** of token cost.

### Prompt Updates

- **New `prompts/planning.md`**: Instructions for security-informed file ranking. Receives grep data, component profiles, threat model. Returns ranked file list with priorities and reasons.
- **Update `prompts/thorough.md`**: Note that files were pre-selected by planning phase — analyze the security-critical subset provided.
- **Update `prompts/opportunistic.md`**: Same — files are the highest-priority subset from planning.

### Updated Audit Flow Integration

In `audit.ts`, after component resolution (step 2) and classification (step 3), the new step 4 is:
1. Run local greps on component-filtered files.
2. Call Claude with grep results + component security profiles + threat model.
3. Select files by token budget based on ranked response.
4. Proceed to batch analysis with selected files.

---

## 8. Report Enhancements

The report page currently shows only: executive summary, security posture, findings, responsible disclosure, comments. Missing: threat model, classification data, component structure, dependencies.

### Threat Model in Report

**`GET /api/audit/:id/report`** changes:
- Join `projects` table to include: `category`, `description`, `involvedParties`, `threatModel`, `threatModelSource`.
- Return these as top-level fields in the report response.

**`src/client/report.ts`** + **`public/report.html`**:
- New "Threat Model" section after executive summary:
  - Source badge: "From Repository" or "Generated by CodeWatch"
  - If evaluation exists: show evaluation text
  - Parties table: Party | Can | Cannot (expandable rows)
- New "Classification" section:
  - Category badge, project description, involved parties summary.

### Component Structure in Report

If components were analyzed for this audit:
- New "Component Breakdown" section showing per-component: name, role, findings count, tokens analyzed.
- Already partially planned in Section 6 (`audit_components` table). The report just needs to render it.

### Dependencies in Report

- Include `project_dependencies` in the report response (join via `project_id`).
- Render as a collapsible section: dependency name, version, ecosystem, linked project link (if exists).
- "Add as Project" button next to unlinked dependencies (requires auth).

### Fix: Synthesis Prompt as File

Move the inline synthesis prompt (audit.ts:454-467) to `prompts/synthesize.md` for consistency and editability.

---

## 9. Supply Chain Navigation

Dependencies identified during component analysis (Section 6) can be registered as CodeWatch projects for audit.

### "Add as Project" Flow

1. User clicks "Add as Project" next to a dependency on the project or report page.
2. Frontend calls `POST /api/projects` with `{ name, githubOrg, repos: [{ repoUrl }] }` — same as existing project creation.
3. If successful, update `project_dependencies.linked_project_id` to point to the new project: `POST /api/dependencies/:id/link` → `{ linkedProjectId }`.
4. The new project appears in "My Projects" and can be analyzed/audited independently.

### Dependency Detection in Component Analysis

The agentic analysis (Section 6) is already exploring repos. Add to its instructions:
- Read manifest files: `package.json`, `go.mod`, `Cargo.toml`, `requirements.txt`, `pom.xml`, `Gemfile`, `pyproject.toml`.
- Extract dependency names, versions, ecosystem.
- For each dependency, attempt to identify the source GitHub repo URL (e.g., npm registry → GitHub link).

Output extends the component analysis JSON:
```json
{
  "components": [...],
  "dependencies": [
    {
      "name": "express",
      "version": "^5.2.1",
      "ecosystem": "npm",
      "repo": "main-repo",
      "source_repo_url": "https://github.com/expressjs/express"
    }
  ]
}
```

After analysis: insert into `project_dependencies` table.

### Future: Large File Handling

For codebases with 5000-10000 LOC files (e.g., simplex-chat), file-level granularity may be too coarse. Starting with file-level and the planning phase for prioritization. If real usage shows this is insufficient, future options:
- **Adaptive granularity**: Files <1000 LOC sent in full; larger files split into sections based on grep hits + function boundaries with ~100-line overlap.
- **Function-level extraction**: Planning phase identifies security-critical functions within large files, sends those functions plus imports/type definitions as context.
- Decision deferred until we have real audit data on large-file codebases.

---

## Implementation Phases

### Phase 1: Gate + Bug Fixes + Migration
- Create `src/server/middleware/gate.ts` + `public/gate.html`
- Mount gate middleware in `index.ts`
- Fix report.ts client to use snake_case keys matching Claude's JSONB output
- Move synthesis prompt to `prompts/synthesize.md`
- Create `sql/002_ownership_and_components.sql` (all schema changes)
- Add `POST /api/audit/:id/unpublish`, `DELETE /api/audit/:id`, `DELETE /api/projects/:id` endpoints
- **Verify**: Gate blocks access without password. Report shows executive summary after fix.

### Phase 2: Ownership Model
- Update `github.ts` (OAuth scope, `getOrgMembershipRole`, `checkGitHubOwnership`)
- Create `ownership.ts` service
- Update `auth.ts` (scope detection, `has_org_scope` storage, state parameter)
- Update `api.ts` (replace all 4 ownership checks, add ownership to project responses)
- Update test mocks and test helpers (`has_org_scope` parameter)
- Add ownership tests
- **Verify**: `npm test` passes, existing auth tests still pass

### Phase 3: Responsible Disclosure
- Remove `notifyOwnerIfNeeded()` from audit.ts, remove `publishable_after` from synthesis
- Add `POST /api/audit/:id/notify-owner` endpoint (creates issue, sets `owner_notified_at`, computes `publishable_after`)
- Update report access control: return 404 for non-owner/non-requester on unpublished reports; owner sees all findings via `resolveOwnership`; everyone else (including requester) sees redacted medium+ findings with support notice
- Update report response: add `isOwner`, `isRequester`, `ownerNotified`, `ownerNotifiedAt`, `redactionNotice`
- Update `report.ts` client: "Notify Owner" button for non-owner requesters, redaction notice banner
- Add notification tests
- **Verify**: `npm test` passes, non-owner sees notify button and redacted findings, time-gating starts from notification

### Phase 4: Project Pages
- Add `GET /api/projects/browse` (public browse, filters, `?mine=true` for user's projects)
- Add `GET /api/projects/:id/detail` (project detail with metadata, audits, components, deps)
- Create `public/projects.html` + `src/client/projects.ts` (browse with "My Projects" checkbox filter)
- Create `public/project.html` + `src/client/project.ts` (project detail)
- Remove `public/reports.html` (superseded by projects page)
- Update nav in `common.ts`
- **Verify**: Public browse shows only projects with public reports. "My Projects" filter visible when logged in.

### Phase 5: Report Enhancements
- Add threat model, classification, involved parties to report API response
- Add "Threat Model" and "Classification" sections to `report.html` + `report.ts`
- Add dependencies section to report (from `project_dependencies`)
- Add component breakdown to report
- **Verify**: Report shows threat model parties, classification, dependencies, component breakdown.

### Phase 6: Shallow Clones + Clone Progress
- Update `cloneOrUpdate()` in `git.ts`: `--depth 1` for initial clones, `--shallow-since` for incremental
- Add `getCommitDate()` to `github.ts` (GitHub API call for base commit timestamp)
- Store clone progress in `audits.progress_detail` JSONB (no new column)
- Update audit flow to report per-repo clone progress
- Add shallow clone tests
- **Verify**: `npm test` passes. Fresh clone uses `--depth 1`. Incremental clone fetches only necessary history window.

### Phase 7: Component Analysis Service
- Install `minimatch`
- Create `componentAnalysis.ts` with tool definitions, agentic loop, component + dependency parsing
- Create `prompts/component_analysis.md`
- Add component analysis API endpoints (start, poll, list)
- Store dependencies in `project_dependencies` table
- Add component analysis tests (mock Claude tool_use responses)
- **Verify**: `npm test` passes, mock analysis produces components + dependencies

### Phase 8: Smart File Selection (Planning Phase)
- Create `src/server/services/planning.ts` (local grep scoring + Claude planning call)
- Create `prompts/planning.md` (planning phase prompt)
- Replace `selectFiles()` in audit.ts with planning-based selection + token budget
- Update `tokens.ts` cost estimation (planning overhead: 105%/38%/15%)
- Update `thorough.md` and `opportunistic.md` prompts
- Update tests for new estimation values and planning step
- **Verify**: `npm test` passes, estimate values reflect planning overhead. Planning uses component security profiles from Phase 7.

### Phase 9: Component Selection + Supply Chain
- Add `POST /api/estimate/components` endpoint
- Modify `POST /api/audit/start` to accept `componentIds`
- Update `runAudit()` for component-based file filtering
- Add finding-to-component attribution
- Update estimate page UI with three-stage flow (free scan → component analysis → audit)
- Add "Add as Project" button for dependencies + `POST /api/dependencies/:id/link`
- Update audit tests
- **Verify**: Full flow — analyze components → select → estimate → audit → report with component breakdown. Dependencies linkable as projects.

---

## Files Modified (Summary)

| File | Changes |
|------|---------|
| `sql/002_ownership_and_components.sql` | **NEW** -- All schema changes (ownership, components, dependencies, audits) |
| `src/server/middleware/gate.ts` | **NEW** -- Password gate middleware |
| `public/gate.html` | **NEW** -- Gate login page |
| `src/server/index.ts` | Mount gate middleware |
| `src/server/services/git.ts` | Shallow clones (`--depth 1`, `--shallow-since`), clone progress tracking |
| `src/server/services/github.ts` | OAuth scope, `getOrgMembershipRole()`, `checkGitHubOwnership()`, `getCommitDate()`, remove `isOrgMember()` |
| `src/server/services/ownership.ts` | **NEW** -- Cached ownership resolution |
| `src/server/services/componentAnalysis.ts` | **NEW** -- Agentic component analysis + security profiling + dependency detection |
| `src/server/services/planning.ts` | **NEW** -- Local grep scoring + Claude planning call |
| `src/server/services/audit.ts` | Remove `notifyOwnerIfNeeded()`, remove `publishable_after` from synthesis, replace `selectFiles()`, add component filtering, finding attribution |
| `src/server/services/tokens.ts` | Fix estimation: planning overhead (105%/38%/15%), add `estimateCostsForComponents()` |
| `src/server/routes/auth.ts` | Scope detection, `has_org_scope`, state parameter, updated requireAuth |
| `src/server/routes/api.ts` | Fix report snake_case→camelCase, replace 4 ownership checks, add ~10 new endpoints (notify-owner, projects/public, my/projects, projects/:id/detail, dependencies/:id/link, etc.), update report with threat model/classification/deps |
| `prompts/component_analysis.md` | **NEW** -- Agentic analysis prompt (components + security + deps) |
| `prompts/planning.md` | **NEW** -- Planning phase prompt |
| `prompts/synthesize.md` | **NEW** -- Moved from inline in audit.ts |
| `prompts/thorough.md` | Update: analyzing security-critical subset selected by planning phase |
| `prompts/opportunistic.md` | Update: analyzing high-priority subset selected by planning phase |
| `public/projects.html` | **NEW** -- Public browse + My Projects page |
| `public/project.html` | **NEW** -- Project detail page |
| `public/report.html` | Add threat model, classification, dependencies, component breakdown sections |
| `src/client/projects.ts` | **NEW** -- Projects browse client |
| `src/client/project.ts` | **NEW** -- Project detail client |
| `src/client/common.ts` | Add `hasOrgScope`, "Projects" nav link, gate cookie handling |
| `src/client/estimate.ts` | Add component analysis UI, selection table, dynamic re-estimation |
| `src/client/report.ts` | Threat model, "Notify Owner" button, component breakdown, dependencies |
| `test/helpers.ts` | Add `hasOrgScope` parameter |
| `test/mocks/github.ts` | Add ownership + membership role mocks |
| `test/api/gate.test.ts` | **NEW** -- Gate middleware tests (8 tests) |
| `test/api/unpublish.test.ts` | **NEW** -- Unpublish + idempotency tests (3 tests) |
| `test/api/delete.test.ts` | **NEW** -- Audit + project deletion tests (9 tests) |
| `test/api/ownership.test.ts` | **NEW** -- Ownership resolution + gated endpoint tests (13 tests) |
| `test/api/auth.test.ts` | Add org scope + returnTo state tests (+5 tests) |
| `test/api/disclosure.test.ts` | **NEW** -- Responsible disclosure + access control tests (12 tests) |
| `test/api/project-pages.test.ts` | **NEW** -- Browse, detail, filters, license tests (16 tests) |
| `test/api/audit.test.ts` | Add report enhancement tests (+7 tests) |
| `test/api/estimate.test.ts` | Add planning overhead cost tests (+2 tests) |
| `test/services/git-shallow.test.ts` | **NEW** -- Shallow clone, getCommitDate, clone progress tests (8 tests) |
| `test/services/planning.test.ts` | **NEW** -- Grep scoring + Claude planning + file selection tests (13 tests) |
| `test/services/componentAnalysis.test.ts` | **NEW** -- Agentic loop, tool execution, parsing, API endpoint tests (18 tests) |
| `test/api/component-selection.test.ts` | **NEW** -- Scoped estimates, component audits, supply chain tests (11 tests) |

---

## Test Plan

All tests use the existing Vitest + integration test infrastructure: `TestContext`, `startTestServer()`, `teardownTestServer()`, `truncateAllTables()`, `authenticatedFetch()`, `vi.mock()` for external services. Tests are organized by feature area, matching the implementation phases.

### Phase 1: Gate + Bug Fixes

**`test/api/gate.test.ts`** (NEW):
- `describe('Development Gate')`:
  - `it('redirects to /gate when no gate cookie')` — GET `/` returns 302 to `/gate`
  - `it('allows access to /gate without cookie')` — GET `/gate` returns 200
  - `it('allows access to /api/health without cookie')` — health endpoint bypasses gate
  - `it('rejects wrong password')` — POST `/gate` with wrong password returns 401
  - `it('sets signed cookie on correct password')` — POST `/gate` with correct password returns Set-Cookie header with signed value
  - `it('allows access with valid gate cookie')` — GET `/` with signed cookie returns 200
  - `it('rejects forged gate cookie')` — GET `/` with unsigned/random cookie returns 302 to `/gate`
  - `it('disables gate when GATE_PASSWORD not set')` — when env unset, all requests pass through

**Updates to `test/api/audit.test.ts`** (existing):
- Add test: `it('report includes executive_summary and security_posture in reportSummary')` — verify report response has `reportSummary.executive_summary` and `reportSummary.security_posture` (snake_case, matching Claude JSONB output) after synthesis completes
- Add test: `it('report filters show only existing severities and statuses')` — verify the API returns filter options scoped to actual findings

**`test/api/unpublish.test.ts`** (NEW, or added to audit.test.ts):
- `it('owner can unpublish a published audit')` — POST `/api/audit/:id/publish` then POST `/api/audit/:id/unpublish` → `is_public = FALSE`, `publishable_after = NULL`
- `it('non-owner cannot unpublish')` — returns 403
- `it('unpublish is idempotent')` — unpublishing already-private audit returns 200

**`test/api/delete.test.ts`** (NEW):
- `describe('DELETE /api/audit/:id')`:
  - `it('requester can delete their own audit')` — returns 204, audit row gone, findings gone
  - `it('other user cannot delete audit')` — returns 403
  - `it('cascades audit_findings, audit_commits')` — verify related rows deleted
  - `it('returns 404 for nonexistent audit')` — returns 404
- `describe('DELETE /api/projects/:id')`:
  - `it('creator can delete project with zero audits')` — returns 204, project + repos + components gone
  - `it('creator can delete project with only own audits')` — cascades own audits, returns 204
  - `it('rejects deletion when other users have audits')` — returns 409 Conflict with error message
  - `it('non-creator cannot delete project')` — returns 403
  - `it('owner (via resolveOwnership) can delete project')` — org admin can delete

### Phase 2: Ownership

**`test/api/ownership.test.ts`** (NEW):
- `describe('resolveOwnership')`:
  - `it('personal account: owner when username matches org')` — `githubOrg === githubUsername` → `isOwner: true`
  - `it('personal account: not owner when username differs')` — different org → `isOwner: false`
  - `it('org account without read:org scope returns needsReauth')` — `has_org_scope = FALSE` → `{ isOwner: false, needsReauth: true }`
  - `it('org account with scope: admin role is owner')` — mock `getOrgMembershipRole` returns `{role: 'admin', state: 'active'}` → `isOwner: true`
  - `it('org account with scope: member role is not owner')` — mock returns `{role: 'member'}` → `isOwner: false`
  - `it('caches ownership result for 15 minutes')` — second call hits cache (no GitHub API call)
  - `it('cache expires after 15 minutes')` — manipulate `expires_at`, second call hits GitHub API
  - `it('re-auth invalidates cache')` — call `invalidateOwnershipCache`, verify next call hits API

- `describe('Ownership-gated endpoints')`:
  - `it('POST /api/audit/start rejects non-owner')` — returns 403
  - `it('POST /api/audit/start allows owner')` — returns 200
  - `it('PATCH /api/findings/:id/status rejects non-owner')` — returns 403
  - `it('POST /api/audit/:id/publish rejects non-owner')` — returns 403
  - `it('returns needsReauth for org without scope')` — returns 403 with `{ needsReauth: true }`

**Updates to `test/api/auth.test.ts`** (existing):
- `it('stores has_org_scope from token exchange')` — verify session row has `has_org_scope = TRUE` when scope includes `read:org`
- `it('re-auth updates has_org_scope')` — re-login with new scope updates session
- `it('GET /auth/me includes hasOrgScope')` — response includes `hasOrgScope` field
- `it('OAuth URL includes read:org scope')` — verify redirect URL scope parameter
- `it('callback respects returnTo state parameter')` — verify redirect after auth

**Updates to `test/mocks/github.ts`** (existing):
- Add `setMockOrgMembershipRole(role)` — mock for `getOrgMembershipRole()`
- Add `setMockCheckOwnership(result)` — mock for `checkGitHubOwnership()`

**Updates to `test/helpers.ts`** (existing):
- `createTestSession()` gains optional `hasOrgScope: boolean` parameter (default `false`)

### Phase 3: Responsible Disclosure

**`test/api/disclosure.test.ts`** (NEW):
- `describe('POST /api/audit/:id/notify-owner')`:
  - `it('requester can notify owner')` — returns `{ ok: true, publishableAfter }`, sets `owner_notified = TRUE`, `owner_notified_at` set
  - `it('creates GitHub issue on notification')` — mock `createIssue` called with expected params
  - `it('sets publishable_after based on max severity')` — critical → 6 months, high → 3 months
  - `it('notification is idempotent')` — second call returns success without creating duplicate issue
  - `it('non-requester cannot notify')` — other user returns 403
  - `it('unauthenticated request returns 401')` — no session returns 401

- `describe('Three-tier report access')`:
  - `it('owner sees all findings via resolveOwnership (Tier 1)')` — owner gets full report, no redaction
  - `it('non-owner requester sees redacted findings list (Tier 2)')` — requester sees severity, category, component per finding; description/file_path/code absent
  - `it('requester redaction notice explains contribution to project security')` — response includes requester-specific `redactionNotice` string
  - `it('anonymous user sees summary only (Tier 3)')` — no session, sees finding count + max severity + audit date, no individual findings
  - `it('other authenticated user sees summary only (Tier 3)')` — non-owner, non-requester, sees summary + "only owners see full report" notice
  - `it('all users see full findings after publishable_after (lazy auto-publish)')` — auto-published, full access for everyone
  - `it('all users see full findings when is_public')` — published by owner, full access for everyone
  - `it('publishable_after is NULL when audit completes')` — verify synthesis does NOT set publishable_after

- `describe('Audit completion changes')`:
  - `it('notifyOwnerIfNeeded is not called on audit completion')` — verify removed
  - `it('publishable_after stays NULL after synthesis')` — verify no time-gating at completion

### Phase 4: Project Pages

**`test/api/project-pages.test.ts`** (NEW):
- `describe('GET /api/projects/browse')`:
  - `it('returns only projects with public audits')` — create 2 projects, publish audit on one, only that one appears
  - `it('returns empty list when no public audits exist')` — no published audits → empty array
  - `it('filters by category')` — `?category=messaging` filters correctly
  - `it('filters by search term')` — `?search=simplex` matches name/org
  - `it('mine=true requires auth')` — unauthenticated returns 401
  - `it('mine=true returns all user projects regardless of public status')` — includes unpublished
  - `it('mine=true includes ownership badges')` — response has `ownership` field
  - `it('includes license from repositories')` — response includes license field
  - `it('includes latestPublicSeverity and publicAuditCount')` — aggregates correct

- `describe('GET /api/projects/:id/detail')`:
  - `it('returns project metadata including license')` — name, org, category, license present
  - `it('returns threat model with parties')` — parties array with can/cannot
  - `it('returns components if analyzed')` — components array with roles, languages, security_profile
  - `it('returns dependencies')` — dependencies array with ecosystem, version
  - `it('returns last 10 audits for owner')` — includes non-public audits for owner
  - `it('returns only public audits for anonymous user')` — non-public audits hidden
  - `it('returns 404 for nonexistent project')` — returns 404

### Phase 5: Report Enhancements

**Updates to `test/api/audit.test.ts`** (existing):
- `it('report includes threat model from classification')` — response has `threatModel` with parties/can/cannot
- `it('report includes category and involvedParties')` — classification data in response
- `it('report includes component breakdown')` — `componentBreakdown` array with name, role, findingsCount
- `it('report includes dependencies')` — `dependencies` array from project_dependencies table
- `it('report includes threatModelSource badge')` — "From Repository" or "Generated by CodeWatch"

### Phase 6: Shallow Clones + Clone Progress

**`test/services/git-shallow.test.ts`** (NEW):
- `describe('Shallow clones')`:
  - `it('initial clone uses --depth 1 --single-branch')` — mock simpleGit, verify clone args include `--depth 1`
  - `it('incremental clone uses --shallow-since')` — pass shallowSince date, verify fetch args include `--shallow-since`
  - `it('incremental without repo on disk clones with --shallow-since')` — no .git dir, verify clone uses `--shallow-since`
  - `it('omits --shallow-since when not provided')` — no date → `--depth 1` only

- `describe('getCommitDate')`:
  - `it('returns commit date from GitHub API')` — mock GitHub API, verify parsed date
  - `it('subtracts 1 day for shallow-since buffer')` — verify the audit flow applies the -1 day buffer

- `describe('Clone progress')`:
  - `it('updates audit progress_detail.clone_progress per repo')` — verify JSONB field updated during clone step
  - `it('reports repo index and name')` — format: `"Cloning 2/5: simplexmq"`

### Phase 7: Component Analysis

**`test/services/componentAnalysis.test.ts`** (NEW):
- `describe('Agentic component analysis')`:
  - `it('creates analysis record in pending status')` — row in `component_analyses` table
  - `it('transitions to running status')` — status='running' during execution
  - `it('calls Claude with tool definitions')` — mock Claude, verify 3 tools defined: `list_directory`, `read_file`, `search_files`
  - `it('executes list_directory tool calls')` — mock Claude requests tool, verify response contains directory listing
  - `it('executes read_file tool calls')` — mock file read tool, verify truncation at 500 lines
  - `it('executes search_files tool calls')` — mock glob search, verify results returned
  - `it('loops until end_turn')` — mock multi-turn: tool_use → tool_use → end_turn with JSON
  - `it('parses components from Claude response')` — verify components inserted into DB with name, role, file_patterns, security_profile
  - `it('parses dependencies from Claude response')` — verify `project_dependencies` rows inserted
  - `it('tracks token usage per turn')` — `input_tokens_used` and `output_tokens_used` accumulated
  - `it('respects max_turns limit')` — stops after 40 turns even if Claude keeps calling tools
  - `it('handles analysis failure gracefully')` — Claude returns error → status='failed', error_message set
  - `it('uses Sonnet 4.5 model')` — verify model parameter in Claude request
  - `it('matches file patterns to scanned files for counts')` — `estimated_files` and `estimated_tokens` populated

- `describe('Component analysis API endpoints')`:
  - `it('POST /api/projects/:id/analyze-components starts analysis')` — returns `{ analysisId }`, status='pending'
  - `it('GET /api/projects/:id/component-analysis/:id returns progress')` — returns turns_used, status, cost
  - `it('GET /api/projects/:id/components lists components')` — returns array with file/token counts
  - `it('requires auth for analysis')` — unauthenticated returns 401
  - `it('rejects analysis for nonexistent project')` — returns 404

### Phase 8: Smart File Selection

**`test/services/planning.test.ts`** (NEW):
- `describe('Local security greps')`:
  - `it('detects injection patterns')` — file with `eval(...)` gets grep hits
  - `it('detects SQL patterns')` — file with `query()` gets hits
  - `it('detects auth patterns')` — file with `password` gets hits
  - `it('returns zero hits for clean files')` — no patterns → `grepHits: 0`
  - `it('limits sample hits to top 3')` — file with many hits returns only 3 samples
  - `it('includes line context in sample hits')` — each sample has pattern, line number, surrounding text

- `describe('Claude planning call')`:
  - `it('sends component security profiles + grep results + threat model')` — mock Claude, verify request includes all three
  - `it('parses ranked file list from Claude response')` — mock Claude returns `[{file, priority, reason}]`, parsed correctly
  - `it('selects files by token budget')` — given 1000 token budget and 3 files (400, 400, 400 tokens), selects first 2
  - `it('full level includes all files')` — 100% budget → all files selected
  - `it('thorough level includes ~33% of tokens')` — token accumulation stops at 33%
  - `it('opportunistic level includes ~10% of tokens')` — stops at 10%
  - `it('stores audit_plan in database')` — verify `audits.audit_plan` JSONB populated

**Updates to `test/api/estimate.test.ts`** (existing):
- `it('cost estimates reflect planning overhead')` — full=105%, thorough=38%, opportunistic=15% of token cost
- `it('shows total file count and tokens once')` — not per-level

### Phase 9: Component Selection + Supply Chain

**`test/api/component-selection.test.ts`** (NEW):
- `describe('POST /api/estimate/components')`:
  - `it('returns scoped cost estimates for selected components')` — subset of components → lower costs
  - `it('handles empty component selection')` — returns zero costs
  - `it('handles all components selected')` — same as full project estimate

- `describe('Component-scoped audits')`:
  - `it('POST /api/audit/start accepts componentIds')` — stored as `selected_component_ids`
  - `it('audit filters files by component glob patterns')` — only matching files analyzed
  - `it('findings are attributed to components')` — `audit_findings.component_id` set
  - `it('report includes per-component breakdown')` — `audit_components` rows with findings_count

- `describe('Supply chain')`:
  - `it('POST /api/dependencies/:id/link links dependency to project')` — sets `linked_project_id`
  - `it('Add as Project creates new project from dependency')` — POST `/api/projects` + link
  - `it('linked dependency shows project badge in responses')` — `linkedProjectId` present
  - `it('cannot link to nonexistent project')` — returns 404

### Test File Summary

| Test File | Phase | New/Modified |
|-----------|-------|--------------|
| `test/api/gate.test.ts` | 1 | **NEW** — 8 tests |
| `test/api/audit.test.ts` | 1, 5 | Modified — +7 tests |
| `test/api/unpublish.test.ts` | 1 | **NEW** — 3 tests |
| `test/api/delete.test.ts` | 1 | **NEW** — 9 tests |
| `test/api/ownership.test.ts` | 2 | **NEW** — 13 tests |
| `test/api/auth.test.ts` | 2 | Modified — +5 tests |
| `test/mocks/github.ts` | 2 | Modified — +2 mock functions |
| `test/helpers.ts` | 2 | Modified — `hasOrgScope` param |
| `test/api/disclosure.test.ts` | 3 | **NEW** — 13 tests |
| `test/api/project-pages.test.ts` | 4 | **NEW** — 16 tests |
| `test/services/git-shallow.test.ts` | 6 | **NEW** — 8 tests |
| `test/services/componentAnalysis.test.ts` | 7 | **NEW** — 18 tests |
| `test/services/planning.test.ts` | 8 | **NEW** — 13 tests |
| `test/api/estimate.test.ts` | 8 | Modified — +2 tests |
| `test/api/component-selection.test.ts` | 9 | **NEW** — 11 tests |


**Totals**: 10 new test files, 4 modified test files, ~127 new tests.

---

## Verification

1. `npm test` -- all existing + new tests pass
2. `npm run test:coverage` -- verify new services have reasonable coverage
3. Manual: visit site without gate cookie → redirected to gate page → enter password → access granted
4. Manual: completed audit report shows executive summary and security posture (bug fix verified)
5. Manual: create project → verify ownership badge (personal account: immediate, org: needs re-auth)
6. Manual: `/projects` page shows only projects with public reports, filters work
7. Manual: `/project/:id` page shows threat model, components, dependencies, audit history
8. Manual: "My Projects" filter shows all user's projects with ownership badges
9. Manual: non-owner audit → report shows "Notify Owner" button → click creates GitHub issue → `publishable_after` set from notification time
10. Manual: owner sees all audits on project (including non-owner audits) with full findings
11. Manual: report shows threat model (parties/can/cannot), classification, dependencies sections
12. Manual: clone progress visible during audit (e.g., "Cloning 2/5: simplexmq")
13. Manual: fresh clone downloads minimal data (verify with `du -sh` — should be fraction of full clone)
14. Manual: incremental audit after shallow clone works (diff between commits succeeds via `--shallow-since`)
15. Manual: estimate page shows three stages — free scan → component analysis → scoped estimates
16. Manual: component analysis populates components table with security profiles + dependencies list
17. Manual: "Add as Project" button on dependency → creates linked project
18. Manual: select/deselect components → costs update dynamically (105%/38%/15% multipliers)
19. Manual: start audit → verify planning phase runs (status='planning', grep hits, Claude planning call)
20. Manual: thorough audit → verify ~38% of tokens sent (planning 5% + analysis 33%)
21. Manual: report shows per-component breakdown with findings count
22. Manual: verify audit_plan stored in DB with ranked file list and reasons

# Reverse Engineering Plan: CodeWatch Product & Spec Documentation

## 1. Problem Statement

CodeWatch has no product requirements or engineering specification documents. All knowledge exists only in code (~98 files, ~18.8K lines of source). This makes it impossible to:
- Verify that code matches intended behavior
- Plan new features against documented requirements
- Onboard contributors who need to understand the system
- Detect regressions where code silently deviates from intended product behavior
- Ensure future AI sessions maintain consistency when modifying the codebase

## 2. Solution Summary

Reverse-engineer the codebase into two documentation layers:

1. **`product/`** — What the system does (user-facing behavior, all views, interactions, scenarios)
2. **`spec/`** — How the system works (architecture, APIs, services, database, design decisions)

Both layers will be:
- 100% derived from code analysis (current behavior, not aspirational)
- Cross-referenced: spec links to code lines, code comments link back to spec
- Maintained by future sessions via CODE.md instructions
- Annotated with `[GAP]` markers for inconsistencies and `[REC]` markers for recommendations

Additionally:
- **`product/screenshots/`** — Playwright-captured PNGs from HTML mockup pages
- **`product/mockups/`** — Standalone HTML files with mock data (source for screenshots)
- **Source code comments** — Function-level `// Spec: spec/...` references added to all src files
- **`CODE.md`** — Updated with instructions for future sessions to maintain product/ and spec/

## 3. Detailed Tech Design

### 3.1 Product Documentation Structure

```
product/
├── README.md                    # Main product document: vision, user personas, capability map
├── views/
│   ├── home.md                  # Home page (project creation wizard)
│   ├── estimate.md              # Cost estimation & audit configuration
│   ├── audit.md                 # Real-time audit progress
│   ├── report.md                # Audit report display
│   ├── project.md               # Project dashboard
│   ├── projects.md              # Project browser
│   └── gate.md                  # Pre-launch access gate
├── flows/
│   ├── project-creation.md      # End-to-end: URL → project → estimate
│   ├── audit-lifecycle.md       # Estimate → start → progress → report
│   ├── responsible-disclosure.md # Notification → redaction → publication
│   ├── authentication.md        # OAuth flow, session management, ownership
│   └── component-analysis.md    # Analysis → selection → scoped audit
├── screenshots/                 # PNG captures from mockups (via Playwright)
│   ├── home-step1.png
│   ├── home-step2.png
│   ├── home-step3.png
│   ├── estimate-overview.png
│   ├── estimate-components.png
│   ├── audit-progress.png
│   ├── report-full.png
│   ├── report-redacted.png
│   ├── project-dashboard.png
│   ├── projects-browse.png
│   └── gate.png
├── mockups/                     # Standalone HTML files for screenshot generation
│   ├── home.html
│   ├── estimate.html
│   ├── audit.html
│   ├── report.html
│   ├── project.html
│   ├── projects.html
│   ├── gate.html
│   └── capture.ts               # Playwright script to render mockups → PNGs
└── gaps.md                      # [GAP] and [REC] annotations collected
```

**Product README.md contents:**
- Product vision and purpose
- Target users (OSS maintainers, security researchers, auditors)
- Capability map (all features grouped by domain)
- Navigation map (page-to-page flow diagram in Mermaid)
- Access control model (owner/requester/public tiers)
- Cross-references to view and flow documents

**Each view document contains:**
- Purpose (one sentence)
- Screenshot reference
- All UI elements with element IDs
- All user interactions (click, input, select, submit)
- All API calls triggered
- State transitions and conditional rendering
- Error states and edge cases
- Navigation: where user comes from, where they go next
- `[GAP]` annotations for missing error handling, dead UI elements, etc.
- `[REC]` annotations for improvement suggestions

**Each flow document contains:**
- Preconditions
- Step-by-step walkthrough with page references
- Decision points and branches
- Error/failure paths
- Mermaid sequence or state diagram
- Post-conditions

### 3.2 Engineering Specification Structure

```
spec/
├── README.md                    # Architecture overview, design decisions, module map
├── architecture.md              # System architecture: layers, data flow, deployment
├── database.md                  # Full schema: tables, columns, types, constraints, indexes, migrations
├── api.md                       # All API endpoints: method, path, auth, request, response, errors
├── auth.md                      # Authentication & authorization: OAuth, sessions, ownership, access tiers
├── services/
│   ├── audit.md                 # Audit orchestration service
│   ├── componentAnalysis.md     # Agentic component analysis
│   ├── github.md                # GitHub API integration
│   ├── planning.md              # Audit planning & file selection
│   ├── tokens.md                # Token counting & cost estimation
│   ├── claude.md                # Claude API wrapper
│   ├── ownership.md             # Ownership resolution & caching
│   ├── git.md                   # Git operations (clone, scan, diff)
│   └── prompts.md               # Prompt template loading & rendering
├── client/
│   ├── README.md                # Client architecture: build, module pattern, shared utilities
│   ├── home.md                  # Home page module
│   ├── estimate.md              # Estimate page module
│   ├── audit.md                 # Audit page module
│   ├── report.md                # Report page module
│   ├── project.md               # Project page module
│   ├── projects.md              # Projects page module
│   └── common.md                # Shared utilities module
├── prompts.md                   # Prompt templates: structure, variables, output schemas
├── config.md                    # Environment variables, defaults, deployment config
├── testing.md                   # Test infrastructure, patterns, fixtures, mocking strategy
└── diagrams/
    ├── system-context.md        # Mermaid: system context diagram
    ├── data-flow.md             # Mermaid: data flow through audit lifecycle
    ├── er-diagram.md            # Mermaid: entity-relationship diagram
    └── state-machines.md        # Mermaid: audit status, finding status, disclosure states
```

**Spec README.md contents:**
- Architecture overview (Express + PostgreSQL + Claude API + GitHub API)
- Design decisions with rationale (why these choices)
- Module dependency graph (Mermaid)
- Cross-reference index: spec file → source files it documents
- Reverse index: source file → spec files that document it

**Each service spec contains:**
- Module purpose (one sentence)
- Source file reference with line numbers
- All exported functions with signatures, parameters, return types
- All database operations (table, operation type, conditions)
- All external API calls (endpoint, method, auth)
- All side effects (file I/O, network, state mutations)
- Error handling behavior
- Dependencies on other modules
- `[GAP]` and `[REC]` annotations

**Link format example:**
```markdown
### [`runAudit()`](../src/server/services/audit.ts) (L45-L320)
```

### 3.3 Source Code Comment Format

Every source file gets a header comment linking to its spec:
```typescript
// Spec: spec/services/audit.md
```

Every exported function gets a comment linking to its spec section:
```typescript
// Spec: spec/services/audit.md#runAudit
export async function runAudit(pool: Pool, options: AuditOptions): Promise<void> {
```

### 3.4 CODE.md Update

Add a new section to CODE.md with RFC-style instructions for maintaining product/ and spec/ documentation. See section 4.8 for details.

### 3.5 Screenshot Generation

1. Create standalone HTML mockup files in `product/mockups/` that:
   - Include the real CSS from `public/css/style.css`
   - Contain hardcoded mock data representing realistic state
   - Are self-contained (no API calls, no server needed)
2. Create a Playwright script (`product/mockups/capture.ts`) that:
   - Opens each mockup in headless Chromium
   - Captures viewport-sized PNG screenshots
   - Saves to `product/screenshots/`
3. Install Playwright and run the capture script

## 4. Detailed Implementation Plan

### Phase 1: Setup & Infrastructure
1. Create `product/` and `spec/` directory structures
2. Create `plan/README.md` (this file)

### Phase 2: Spec Layer (bottom-up — code first, then abstractions)
Write in this order because each document builds on knowledge from the previous:

1. **spec/config.md** — Environment variables, defaults
2. **spec/database.md** — Full schema from SQL migrations
3. **spec/diagrams/er-diagram.md** — ER diagram from schema
4. **spec/services/git.md** — Git operations (no dependencies)
5. **spec/services/prompts.md** — Prompt loading (no dependencies)
6. **spec/services/claude.md** — Claude API wrapper (no dependencies)
7. **spec/services/tokens.md** — Token counting (depends on DB)
8. **spec/services/github.md** — GitHub API (no internal dependencies)
9. **spec/services/ownership.md** — Ownership (depends on github)
10. **spec/services/planning.md** — Planning (depends on claude, prompts)
11. **spec/services/audit.md** — Audit orchestration (depends on all above)
12. **spec/services/componentAnalysis.md** — Component analysis (depends on claude)
13. **spec/auth.md** — Auth routes + middleware (depends on github, ownership)
14. **spec/api.md** — All API endpoints (depends on all services)
15. **spec/prompts.md** — Prompt templates documentation
16. **spec/client/common.md** — Shared client utilities
17. **spec/client/home.md** through **spec/client/projects.md** — Client modules
18. **spec/client/README.md** — Client architecture overview
19. **spec/testing.md** — Test infrastructure
20. **spec/architecture.md** — System architecture overview
21. **spec/diagrams/system-context.md** — System context diagram
22. **spec/diagrams/data-flow.md** — Data flow diagram
23. **spec/diagrams/state-machines.md** — State machine diagrams
24. **spec/README.md** — Main spec document with cross-reference index

### Phase 3: Product Layer (top-down — views, flows, capabilities)
1. **product/views/gate.md** — Simplest page
2. **product/views/home.md** — Project creation wizard
3. **product/views/estimate.md** — Cost estimation
4. **product/views/audit.md** — Audit progress
5. **product/views/report.md** — Report display
6. **product/views/project.md** — Project dashboard
7. **product/views/projects.md** — Project browser
8. **product/flows/authentication.md** — OAuth + sessions
9. **product/flows/project-creation.md** — End-to-end creation
10. **product/flows/audit-lifecycle.md** — Full audit cycle
11. **product/flows/responsible-disclosure.md** — Disclosure workflow
12. **product/flows/component-analysis.md** — Analysis workflow
13. **product/gaps.md** — Collected gaps and recommendations
14. **product/README.md** — Main product document

### Phase 4: Screenshots
1. Create HTML mockup files in `product/mockups/`
2. Create Playwright capture script
3. Install Playwright, run captures
4. Verify screenshots, add to product view docs

### Phase 5: Source Code Annotations
1. Add file-level spec references to all 17 server src files
2. Add function-level spec references to all exported functions
3. Add file-level spec references to all 7 client src files

### Phase 6: CODE.md Update
1. Add documentation maintenance instructions to CODE.md

### Phase 7: Adversarial Self-Review
1. Verify every src file is referenced in spec (completeness)
2. Verify every spec claim matches actual code (accuracy)
3. Verify every product view matches actual HTML/TS (consistency)
4. Verify all cross-references resolve (link integrity)
5. Verify gaps.md captures all `[GAP]` annotations
6. Fix all issues found
7. Repeat until 2 consecutive passes find no issues

## 5. Execution Notes

- Phases 2-3 will be parallelized where possible (independent spec files can be written concurrently)
- Each document will be written by reading the actual source code, not from memory or summaries
- Line numbers in spec will be verified against actual source at time of writing
- The plan itself will be updated as work progresses to track deviations

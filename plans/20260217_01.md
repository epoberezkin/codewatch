# Fix Threat Model Display on Project & Report Pages

## 1. Problem Statement

The project page and report page display raw JSON instead of a formatted threat model table. Two root causes:

**A. Structural mismatch between prompt output and client expectations:**
- **Prompt produces**: `involved_parties` = `{vendor, operators, end_users, networks}` (role metadata); `threat_model.parties` = `[{name, can, cannot}]` (security threat model)
- **Client expects**: `involvedParties` = `Record<string, {can, cannot}>` (the can/cannot data, keyed by party name)

The client renders `involvedParties` as a party/can/cannot table, but it contains role metadata (strings/arrays). The actual can/cannot data lives in `threat_model.parties`, stored in the `threat_model` TEXT column as a JSON string (when `generated` is falsy).

**B. `threat_model_files` discarded at classification time:**
- Claude returns `threat_model_files: ["SECURITY.md", ...]` listing files where it found threat models
- This data is never stored — used only to derive `threat_model_source` (`repo` vs `generated`)
- No way to link back to the source files on GitHub

### Verified data flow (all consumers)

| # | Location | What it does | Bug? |
|---|----------|-------------|------|
| 1 | **Storage** (audit.ts:735) | `JSON.stringify(classification.involved_parties)` → JSONB | No — faithful storage |
| 2 | **Storage** (audit.ts:736) | `classification.threat_model?.generated \|\| JSON.stringify(classification.threat_model)` → TEXT | No — stores generated text or full JSON object |
| 3 | **API /api/projects/:id** (api.ts:562-564) | Passes `involved_parties` (JSONB→object) and `threat_model` (TEXT→string) directly | Bug: no parsing, no defaults |
| 4 | **API /api/audit/:id/report** (api.ts:1457-1459) | Same direct passthrough | Bug: same |
| 5 | **Client project.ts** (lines 132-171) | Reads `involvedParties` as `Record<string, {can, cannot}>`, iterates with `Object.entries` | Bug: wrong shape — gets `{vendor: "org", operators: [...]}` |
| 6 | **Client report.ts** (lines 202-240) | Same rendering logic as project.ts | Bug: same |
| 7 | **Server planning.ts** (lines 283-287) | Reads `classification.threat_model.parties` after DB round-trip via audit.ts:350-363 | No bug — correctly parses JSON |
| 8 | **Server audit.ts** (lines 347-363) | Parses `threat_model` TEXT back to structured object for internal reuse | No bug — already handles both cases |

### Test fixture shape (audit.test.ts:11-31)

The test mock `classificationResponse` uses:
- `involved_parties: {vendor: "test-org", operators: ["server operators"], ...}` — matches prompt
- `threat_model: {generated: "Server operators can access all user data.", parties: [{name, can, cannot}]}` — matches prompt

The test `project-pages.test.ts:458-476` manually inserts `involvedParties` with `{vendor: {can, cannot}}` shape — this is the **wrong** shape that doesn't match what Claude actually produces. This test will need updating.

## 2. Solution Summary

1. **DB migration**: Add `threat_model_files TEXT[]` column to `projects` table
2. **Storage**: Persist `threat_model_files` from classification response
3. **API layer**: Parse `threat_model` TEXT column into structured fields. Extract `threatModelParties` (can/cannot array). Construct GitHub file links from `threat_model_files` + commit SHA from `audit_commits`. Supply defaults for missing fields.
4. **Client layer**: Update `ProjectDetail` and report interfaces. Render threat model as: evaluation text → source file link(s) → parties table. Remove broken `involvedParties` rendering (role metadata kept in API but not displayed).
5. **Tests**: Update fixtures and assertions to match new API shape.
6. **Spec**: Add backwards-compatibility note. Update field documentation.

No changes to: prompt, planning.ts, or audit.ts internal reuse (lines 347-363).

## 3. Detailed Technical Design

### 3.1 DB Migration (`sql/005_threat_model_files.sql`)

```sql
ALTER TABLE projects ADD COLUMN threat_model_files TEXT[] DEFAULT '{}';
```

Simple additive column. Default `'{}'` (empty array) means existing rows remain valid without backfill.

### 3.2 Storage Change (`audit.ts:classifyProject`, lines 722-741)

Add `threat_model_files` to the UPDATE query:

```sql
UPDATE projects SET
  category = $1, description = $2, involved_parties = $3,
  threat_model = $4, threat_model_source = $5,
  threat_model_files = $6,
  classification_audit_id = $7
WHERE id = $8
```

Parameter: `classification.threat_model_files || []` (the string array from Claude's response).

### 3.3 API Response Shape Change

**Current** (both endpoints):
```typescript
{
  involvedParties: {vendor: "org", operators: ["..."], ...} | null,
  threatModel: "JSON string or plain text" | null,
  threatModelSource: "repo" | "generated" | null,
}
```

**New** (both endpoints):
```typescript
{
  involvedParties: {vendor?: string, operators?: string[], end_users?: string[], networks?: string[]} | null,
  threatModel: string | null,                                                       // evaluation/generated text
  threatModelParties: Array<{name: string, can: string[], cannot: string[]}>,        // security parties
  threatModelFileLinks: Array<{path: string, url: string}>,                          // GitHub links to source files
  threatModelSource: "repo" | "generated" | null,
}
```

### 3.4 API Parsing Logic

**`parseThreatModel` helper** (new function in `api.ts`):

```typescript
function parseThreatModel(raw: string | null): {
  text: string | null;
  parties: Array<{name: string; can: string[]; cannot: string[]}>
} {
  if (!raw) return { text: null, parties: [] };
  try {
    const parsed = JSON.parse(raw);
    if (typeof parsed === 'object' && parsed !== null) {
      const text = parsed.evaluation || parsed.generated || null;
      const parties = Array.isArray(parsed.parties) ? parsed.parties : [];
      return { text, parties };
    }
  } catch { /* not JSON — treat as plain text */ }
  return { text: raw, parties: [] };
}
```

**`buildThreatModelFileLinks` helper** (new function in `api.ts`):

Constructs GitHub blob URLs from `threat_model_files` + commit data.

Note: Claude sees file paths with repo-name prefix (audit.ts:143 prefixes all paths with `${repo.repo_name}/`). So `threat_model_files` entries look like `"repo-name/SECURITY.md"`. The helper must parse the prefix to match the correct repo and strip it for the GitHub blob URL.

```typescript
function buildThreatModelFileLinks(
  threatModelFiles: string[] | null,
  commits: Array<{repo_url: string; repo_name: string; commit_sha: string}>
): Array<{path: string; url: string}> {
  if (!threatModelFiles?.length || !commits.length) return [];
  return threatModelFiles
    .filter(f => f && !f.includes('..') && !f.startsWith('/'))   // sanitize LLM output
    .map(filePath => {
      // Parse repo-name prefix: "repo-name/path/to/file" → repo_name="repo-name", fileInRepo="path/to/file"
      const slashIdx = filePath.indexOf('/');
      const repoPrefix = slashIdx > 0 ? filePath.substring(0, slashIdx) : '';
      const fileInRepo = slashIdx > 0 ? filePath.substring(slashIdx + 1) : filePath;

      // Match repo by name prefix, fallback to first commit
      const commit = commits.find(c => c.repo_name === repoPrefix) || commits[0];
      const url = `${commit.repo_url}/blob/${commit.commit_sha}/${encodeURI(fileInRepo)}`;
      return { path: filePath, url };
    });
}
```

**Sanitization**: Reject paths with `..` or absolute paths. The URL is constructed from our stored `repo_url` (always `https://github.com/...`) so it cannot be an arbitrary URL. `encodeURI` handles special characters in file paths.

### 3.5 API Endpoint Changes

**GET /api/projects/:id** (api.ts, ~line 555):

Before the response, add:
```typescript
const tm = parseThreatModel(project.threat_model);

// Get classification audit commits for file links
let classificationCommits: Array<{repo_url: string; repo_name: string; commit_sha: string}> = [];
if (project.classification_audit_id && project.threat_model_files?.length) {
  const { rows } = await pool.query(
    `SELECT r.repo_url, r.repo_name, ac.commit_sha
     FROM audit_commits ac
     JOIN repositories r ON r.id = ac.repo_id
     WHERE ac.audit_id = $1`,
    [project.classification_audit_id]
  );
  classificationCommits = rows;
}
const threatModelFileLinks = buildThreatModelFileLinks(project.threat_model_files, classificationCommits);
```

Response fields:
```typescript
involvedParties: project.involved_parties || null,
threatModel: tm.text,
threatModelParties: tm.parties,
threatModelFileLinks,
threatModelSource: project.threat_model_source || null,
```

**GET /api/audit/:id/report** (api.ts, ~line 1441):

The report endpoint already JOINs projects. Need to add `p.threat_model_files, p.classification_audit_id` to the SELECT (line 1276). Then apply same parsing logic.

The report endpoint already queries `audit_commits` (line 1314-1320). For file links we need the **classification audit's** commits (not the current audit's), since threat model files are from classification time. Add a separate query using `project.classification_audit_id` if it differs from the current audit.

### 3.6 Client Changes

**project.ts interface** (lines 14-16):
```typescript
involvedParties: Record<string, unknown> | null;
threatModel: string | null;
threatModelParties: Array<{name: string; can: string[]; cannot: string[]}>;
threatModelFileLinks: Array<{path: string; url: string}>;
threatModelSource: string | null;
```

**project.ts rendering** (lines 131-171) — replace existing threat model block:

Display order (per user requirement: "first what is at threat model, then the link to source"):

1. Show threat model source badge (repo/generated) — keep existing logic
2. Show `project.threatModel` as evaluation/generated text (if present)
3. Show `project.threatModelFileLinks` as clickable links — check `url.startsWith('https://')` before rendering as `<a>` (defense in depth, though API already sanitizes)
4. Show `project.threatModelParties` as the can/cannot table (move existing table rendering to use this field)

`involvedParties` (role metadata: vendor, operators, etc.) is **not displayed** in the threat model section — it remains in the API response for future use but is not rendered. The can/cannot table uses `threatModelParties` instead.

**report.ts** — mirror the same changes (lines 40-42, 200-240).

### 3.7 Test Changes

**project-pages.test.ts:458-476**: Update the test to:
- Store `involved_parties` as `{vendor: "org", operators: [...]}` (matching prompt shape)
- Store `threat_model` as `JSON.stringify({evaluation: "Security assessment", parties: [{name: "vendor", can: ["Access servers"], cannot: ["Read messages"]}]})`
- Assert on `involvedParties.vendor` (string), `threatModelParties[0].name`, `threatModelParties[0].can[0]`

**audit.test.ts:525-537**: Existing `involvedParties` assertions are already correct (`.vendor` is `"test-org"` string, `.operators` contains `"server operators"`). Add new assertions:
- `report.threatModelParties` is `[]` (empty — mock has `generated` truthy, so storage discards parties per known limitation in section 3.9)
- `report.threatModelFileLinks` is `[]` (empty — mock has `threat_model_files: []`)

**audit.test.ts:540-552**: Existing `threatModel` assertions are already correct — `report.threatModel` is `"Server operators can access all user data."` (plain text, not JSON blob). No change needed.

### 3.8 Spec Updates

- **spec/api.md**: Update GET /api/projects/:id and GET /api/audit/:id/report response schemas to document `threatModelParties`, `threatModelFileLinks` fields and new `threatModel` semantics
- **spec/client/project.md**: Update interface documentation and rendering description
- **spec/client/report.md**: Mirror project.md changes
- **spec/database.md**: Document new `threat_model_files TEXT[]` column
- **spec/services/audit.md**: Document storage of `threat_model_files` in `classifyProject`
- Add backwards-compatibility note to spec/api.md: "The `threat_model` TEXT column may contain either plain text or a JSON string. API consumers MUST handle both. Future schema extensions to classification data MUST be backwards-compatible with existing stored data."

### 3.9 Known Limitation

When `threat_model.generated` is truthy (audit.ts:736), the storage code saves only the generated text string, discarding the `parties` array from the JSON object. For such projects (where `threat_model_found=false`), `threatModelParties` will be `[]` and no parties table is shown. This is a **pre-existing storage behavior** — not introduced by this fix. The generated text is still displayed. Fixing this would require changing the storage format, which is out of scope.

### 3.10 Backwards Compatibility

- `involvedParties` shape is unchanged (role metadata object) — existing data works; not displayed in threat model section
- `threatModel` changes from raw JSON string to parsed evaluation text — breaking for clients that parse the JSON string directly. Since we control the only clients, this is acceptable.
- New `threatModelParties` and `threatModelFileLinks` fields are additive
- `threat_model_files` defaults to `'{}'` — existing projects get empty links, which is correct (no source files known)
- Stored data in DB is unchanged — the API parsing handles both JSON and plain text

## 4. Detailed Implementation Steps

1. **Add migration** `sql/005_threat_model_files.sql`
2. **Update `classifyProject`** in `audit.ts` (lines 722-741) to store `threat_model_files`
3. **Add `parseThreatModel` and `buildThreatModelFileLinks` helpers** to `api.ts`
4. **Update GET /api/projects/:id** response (api.ts ~lines 555-564): add commit query, apply helpers
5. **Update GET /api/audit/:id/report** query and response (api.ts ~lines 1276, 1455-1459): add `p.threat_model_files, p.classification_audit_id` to SELECT, apply helpers
6. **Update `ProjectDetail` interface** in `project.ts` (lines 14-16)
7. **Update `renderProject` threat model rendering** in `project.ts` (lines 131-171)
8. **Update report interface and rendering** in `report.ts` (lines 40-42, 200-240)
9. **Update test fixtures and assertions** in `project-pages.test.ts`, `audit.test.ts`
10. **Update spec docs**: `spec/api.md`, `spec/client/project.md`, `spec/client/report.md`, `spec/database.md`, `spec/services/audit.md`
11. **Add backwards-compatibility note** to `spec/api.md`
12. **Run adversarial self-review** across product/spec/src layers
